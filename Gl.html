<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>גלריה מגנטית אנכית</title>
    <style>
        body {
            margin: 0;
            /* --- שינוי: מאפשרים גלילה אנכית לדף --- */
            overflow-y: auto;
            overflow-x: hidden; /* מונע גלילה אופקית מיותרת */
            background-color: #2c3e50; /* רקע כהה יותר */
        }

        #physics-container {
            /* --- שינוי: קונטיינר צר וארוך מאוד --- */
            width: 320px; /* רוחב "צינור" */
            max-width: 90%;
            height: 300vh; /* גובה גדול מאוד, מאפשר גלילה */
            position: relative;
            border-left: 2px solid #7f8c8d; /* רק קירות צד ויזואליים */
            border-right: 2px solid #7f8c8d;
            margin: 0 auto; /* ממקם במרכז הדף */
            background-color: #34495e;
            /* שינוי: מוסתר כדי לחתוך את הכרטיסיות בגבולות, אבל הגלילה היא של הדף */
            overflow: hidden;
        }

        .work-card {
            position: absolute;
            background-color: #e74c3c;
            color: white;
            padding: 20px;
            /* border-radius: 0; */ /* פינות ישרות? */
            box-shadow: 0px 0px 10px rgba(0,0,0,0.4);
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* מרכוז תוכן */
            text-align: center;
             /* --- שינוי: רוחב 100%, גובה כמעט מלא --- */
            width: 100%;
            height: 95vh; /* גובה כמעט מלא של החלון */
            box-sizing: border-box;
            will-change: transform, top, left;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* הסרנו left: 2.5% */
            border-bottom: 1px solid #c0392b; /* קו הפרדה קל */
        }

        .work-card img {
            max-width: 70%;
            max-height: 60%;
            height: auto;
            margin-bottom: 15px;
            pointer-events: none;
        }
        .work-card span {
             font-size: 1.2em;
             pointer-events: none;
        }

    </style>
</head>
<body>

<div id="physics-container">
    <div class="work-card">
        <img src="placeholder.png" alt="עבודה 1">
        <span>כרטיס מגנטי 1</span>
    </div>
    <div class="work-card">
        <img src="placeholder.png" alt="עבודה 2">
        <span>כרטיס מגנטי 2</span>
    </div>
    <div class="work-card">
        <img src="placeholder.png" alt="עבודה 3">
        <span>כרטיס מגנטי 3</span>
    </div>
     <div class="work-card">
        <span>טקסט בלבד 4</span>
    </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-attractors/0.1.6/matter-attractors.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // ודא שהפלאגין נטען לפני השימוש בו
        if (typeof MatterAttractors === 'undefined') {
            console.error('MatterAttractors פלאגין לא נטען!');
            return;
        }

        const Engine = Matter.Engine;
        const Runner = Matter.Runner;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body; // גישה ישירה ל-Body
        const Composite = Matter.Composite;
        const Mouse = Matter.Mouse;
        const MouseConstraint = Matter.MouseConstraint;
        const Events = Matter.Events;

        // --- שינוי: שימוש בפלאגין ---
        Matter.use('matter-attractors'); // הפעלת הפלאגין

        const container = document.getElementById('physics-container');
        let containerRect = container.getBoundingClientRect();
        const cards = Array.from(container.querySelectorAll('.work-card'));

        const engine = Engine.create();
        const world = engine.world;
        // --- שינוי: אפס כבידה ---
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 0;

        // --- שינוי: רק קירות צד, גבוהים מאוד ---
        const wallThickness = 100; // קירות עבים יותר (מחוץ למסך) למניעת בריחה
        const wallOptions = {
            isStatic: true,
            render: { visible: false }
        };

        let leftWall, rightWall;

        function updateWalls() {
            containerRect = container.getBoundingClientRect(); // חשוב לעדכן מידות
            // גובה הקירות צריך להיות גדול מאוד, תואם לגובה הקונטיינר או יותר
            const wallHeight = containerRect.height * 1.1; // קצת יותר גבוה מהקונטיינר

            if (leftWall) Composite.remove(world, [leftWall, rightWall]); // הסר קודמים אם קיימים

            // ממקם את הקירות מחוץ לגבולות הנראים של הקונטיינר
            leftWall = Bodies.rectangle(
                -wallThickness / 2, // X מחוץ לגבול השמאלי
                containerRect.height / 2, // Y במרכז הגובה של הקונטיינר
                wallThickness,
                wallHeight,
                wallOptions
            );
            rightWall = Bodies.rectangle(
                containerRect.width + wallThickness / 2, // X מחוץ לגבול הימני
                containerRect.height / 2, // Y במרכז הגובה של הקונטיינר
                wallThickness,
                wallHeight,
                wallOptions
            );

            Composite.add(world, [leftWall, rightWall]);
        }

        updateWalls(); // קריאה ראשונית

        // --- שינוי: מיקום התחלתי ופרמטרים של הכרטיסיות ---
        const cardBodies = cards.map((card, index) => {
            // גובה הכרטיסיה מחושב דינמית (בערך)
            const cardHeight = window.innerHeight * 0.95; // 95% מגובה החלון
            const cardWidth = containerRect.width; // רוחב מלא של הקונטיינר

            // עדכון CSS של הכרטיסיה כדי להתאים לגובה המחושב (למקרה שה-CSS לא הספיק)
            card.style.height = `${cardHeight}px`;

            // מיקום התחלתי: מפוזרים אנכית
            const initialX = containerRect.width / 2 + (Math.random() * 10 - 5);
            // פיזור לאורך הקונטיינר הגבוה
            const initialY = (index * (cardHeight * 1.1)) + cardHeight / 2 + 50; // מרווח התחלתי גדול


            const body = Bodies.rectangle(
                initialX, initialY, cardWidth, cardHeight,
                {
                    frictionAir: 0.04, // חיכוך אוויר משמעותי יותר באפס כבידה
                    friction: 0.01,    // חיכוך נמוך מאוד עם משטחים (פחות רלוונטי)
                    restitution: 0.3, // קפיציות נמוכה
                    // --- שינוי: הגדרות פלאגין משיכה ---
                    plugin: {
                        attractors: [
                            // פונקציית משיכה בין גופים (דומה לכבידה)
                            function(bodyA, bodyB) {
                                // כוח משיכה ריבועי הפוך, אך עם הגבלות
                                let forceMagnitude = 0.005; // עוצמת המשיכה (לכוונון!)
                                let dx = bodyB.position.x - bodyA.position.x;
                                let dy = bodyB.position.y - bodyA.position.y;
                                let distanceSq = dx * dx + dy * dy;
                                let minDistanceSq = 150 * 150; // לא למשוך אם קרובים מדי
                                let maxDistanceSq = (window.innerHeight * 1.5) ** 2; // טווח משיכה (לכוונון!)

                                if (distanceSq < maxDistanceSq && distanceSq > minDistanceSq) {
                                   let force = (forceMagnitude * bodyA.mass * bodyB.mass) / distanceSq;
                                   // כוח מוגבל למניעת "פיצוץ"
                                   let maxForce = 0.05;
                                   force = Math.min(force, maxForce);
                                   return {
                                     x: dx * force,
                                     y: dy * force
                                   };
                                }
                                return { x: 0, y: 0 };
                            }
                        ]
                    }
                }
            );

            // --- שינוי: מניעת סיבוב ---
            Body.setInertia(body, Infinity);

            body.element = card;
            card.body = body;
            return body;
        });

        Composite.add(world, cardBodies);

        // הוספת שליטה עם העכבר
        const mouse = Mouse.create(container);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.1, // גרירה רכה יותר
                render: { visible: false }
            }
        });
        Composite.add(world, mouseConstraint);

        // לולאת עדכון לסינכרון ה-HTML
        Events.on(engine, 'afterUpdate', () => {
            cardBodies.forEach(body => {
                const element = body.element;
                if (element) {
                    // מיקום מדויק ללא סיבוב
                    element.style.left = `${body.position.x - element.offsetWidth / 2}px`;
                    element.style.top = `${body.position.y - element.offsetHeight / 2}px`;
                    // --- שינוי: הסרנו עדכון סיבוב ---
                    // element.style.transform = `rotate(${body.angle}rad)`;
                }
            });
        });

        const runner = Runner.create();
        Runner.run(runner, engine);

         // עדכון בשינוי גודל חלון
         window.addEventListener('resize', () => {
             // עדכון קירות
             updateWalls();

             // עדכון גודל ומיקום כרטיסיות (יכול להיות מורכב)
             cardBodies.forEach(body => {
                 const element = body.element;
                 const newCardHeight = window.innerHeight * 0.95;
                 const newCardWidth = containerRect.width; // כבר עודכן ב-updateWalls

                 element.style.height = `${newCardHeight}px`;

                 // צריך לשנות גם את הגוף הפיזיקלי עצמו!
                 // קנה מידה של הגוף הפיזיקלי יכול להיות פתרון
                 const scaleX = newCardWidth / (body.bounds.max.x - body.bounds.min.x);
                 const scaleY = newCardHeight / (body.bounds.max.y - body.bounds.min.y);
                 Body.scale(body, scaleX, scaleY);

                 // ייתכן שנצטרך גם למקם מחדש כדי למנוע חפיפות מוזרות אחרי שינוי גודל
                 // Body.setPosition(body, { x: newX, y: newY });
             });
             // הערה: שינוי גודל דינמי של גופים פיזיקליים תוך כדי סימולציה
             // יכול להיות מאתגר ולגרום להתנהגות לא צפויה לפעמים.
         });
    });
</script>

</body>
</html>
