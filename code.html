<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <title>מסע בין נוירונים וטיפות – מודולים, כל כוכב הוא נוירון</title>
  <link href="https://fonts.googleapis.com/css2?family=Exo:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0; 
      overflow: hidden; 
      background-color: #000; 
      font-family: 'Exo', sans-serif;
    }
    canvas {
      display: block;
    }
    /* כפתור התחל מסע */
    #startButton {
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%);
      padding: 20px 40px; 
      background-color: rgba(0,170,255,0.7); 
      color: #fff; 
      border: none;
      font-size: 24px; 
      cursor: pointer; 
      border-radius: 10px; 
      z-index: 5;
    }
    #startButton:hover {
      background-color: rgba(0,170,255,1);
    }
    /* HUD */
    #hud {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      color: #fff; 
      font-size: 16px; 
      z-index: 3;
    }
    #hud p {
      margin: 5px 0;
    }
    /* ממשק שליטה */
    #controlsOverlay {
      position: absolute; 
      bottom: 20px; 
      right: 20px; 
      color: #fff; 
      font-size: 14px; 
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px; 
      border-radius: 8px; 
      z-index: 3;
    }
    #controlsOverlay p {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <button id="startButton">התחל מסע</button>
  
  <div id="hud">
    <p>מצערת: <span id="throttleValue">1</span></p>
    <p>טייס אוטומטי: <span id="autopilotStatus">OFF</span></p>
  </div>
  
  <div id="controlsOverlay">
    <p>שליטה:</p>
    <p>W, A, S, D: תנועה</p>
    <p>חיצים: סיבוב</p>
    <p>גלגלת עכבר: טיפה (נוירון) הבאה/קודמת</p>
    <p>SHIFT + גלגלת: שינוי FOV</p>
    <p>+/-: הגברת/הפחתת מצערת</p>
    <p>T: טייס אוטומטי</p>
    <p>H: הצגת/הסתרת HUD</p>
    <p>Home: Zoom Out</p>
  </div>

  <!-- טעינה כ־type="module" למניעת שגיאות import/export -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128/build/three.module.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/postprocessing/ShaderPass.js';
    import { RGBShiftShader } from 'https://cdn.jsdelivr.net/npm/three@0.128/examples/jsm/shaders/RGBShiftShader.js';
    import { TWEEN } from 'https://cdn.jsdelivr.net/npm/tween.js@18.6.4/dist/tween.esm.js';
    
    let scene, camera, renderer, composer;
    let canvas = document.getElementById('scene');
    let startButton = document.getElementById('startButton');
    
    let hudVisible = true;
    let throttle = 1, speed = 1, autopilot = false;
    let velocity = new THREE.Vector3();
    let rotation = new THREE.Vector3();
    const dampingFactor = 0.95;
    let clock = new THREE.Clock();
    let animateRunning = false;
    
    let points = []; // כאן יאוחסנו ה"נוירונים" (כוכבים)
    let currentIndex = -1;
    let autopilotTimer;
    
    let userPath = [];
    let userPathLine;
    let keyStates = {};
    
    // "כבידה", לא בהכרח בשימוש אבל אפשרי
    let gravity = 0.1;
    
    // פונקציה עזר לצבעים (לא בהכרח בשימוש)
    function interpolateColor(stress, c1, c2){
      let ratio = stress/10;
      ratio = Math.min(Math.max(ratio,0),1);
      let r = Math.round(c1[0] + ratio*(c2[0]-c1[0]));
      let g = Math.round(c1[1] + ratio*(c2[1]-c1[1]));
      let b = Math.round(c1[2] + ratio*(c2[2]-c1[2]));
      return `rgb(${r},${g},${b})`;
    }

    // אתחול הסצנה
    function init(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500000);
      camera.position.set(0, 5, 5000);

      renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      // תאורה
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      // נטען טקסטורה חלופית לרקע
      const loader = new THREE.TextureLoader();
      loader.load('https://raw.githubusercontent.com/mrdoob/three.js/r128/examples/textures/2294472375_24a3b8ef46_o.jpg',(texture)=>{
        scene.background = texture;
      });
      
      // נייצר "נוירונים" – כדורים אדומים
      createNeurons();
      connectNeurons();
      createUserPathLine();
      
      // יצירת אפקט פוסט-פרוססינג
      const renderPass = new RenderPass(scene, camera);
      composer = new EffectComposer(renderer);
      composer.addPass(renderPass);
      const rgbShift = new ShaderPass(RGBShiftShader);
      rgbShift.uniforms['amount'].value = 0.001;
      composer.addPass(rgbShift);

      // האזנה לאירועים
      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('wheel', onWheel, false);
    }
    
    function createNeurons(){
      // מייצרים ~10 "כוכבים" (נוירונים)
      for (let i=0; i<10; i++){
        let geo = new THREE.SphereGeometry(100, 32, 32);
        let mat = new THREE.MeshBasicMaterial({color: 0xff0000});
        let sphere = new THREE.Mesh(geo, mat);
        // מיקום אקראי, כמו כוכבים רחוקים
        sphere.position.set(
          (Math.random()-0.5)*10000,
          (Math.random()-0.5)*10000,
          (Math.random()-0.5)*10000
        );
        sphere.userData.name = `Neuron ${i+1}`;
        scene.add(sphere);
        points.push(sphere);
      }
    }
    
    function connectNeurons(){
      // מחברים כל נוירון לכולם בעזרת עקומות
      for (let i=0; i<points.length; i++){
        for (let j=i+1; j<points.length; j++){
          let curve = new THREE.CatmullRomCurve3([
            points[i].position,
            new THREE.Vector3(
              (points[i].position.x + points[j].position.x)/2 + (Math.random()-0.5)*1000,
              (points[i].position.y + points[j].position.y)/2 + (Math.random()-0.5)*1000,
              (points[i].position.z + points[j].position.z)/2 + (Math.random()-0.5)*1000
            ),
            points[j].position
          ]);
          let pts = curve.getPoints(20);
          let geo = new THREE.BufferGeometry().setFromPoints(pts);
          let mat = new THREE.LineBasicMaterial({color:0xaaaaaa, transparent:true, opacity:0.1});
          let line = new THREE.Line(geo, mat);
          scene.add(line);
        }
      }
    }
    
    function createUserPathLine(){
      userPathLine = new THREE.Line(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({color:0xffff00, transparent:true, opacity:0.15})
      );
      scene.add(userPathLine);
    }
    
    function updateUserPath(){
      const positions = [];
      userPath.forEach(p=>{
        positions.push(p.x, p.y, p.z);
      });
      userPathLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      userPathLine.geometry.needsUpdate = true;
    }
    
    function animate(){
      if(!animateRunning) return;
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      
      velocity.multiplyScalar(dampingFactor);
      rotation.multiplyScalar(dampingFactor);
      
      camera.position.add(velocity);
      camera.rotation.x += rotation.x*delta;
      camera.rotation.y += rotation.y*delta;
      camera.rotation.z += rotation.z*delta;
      
      TWEEN.update();
      composer.render();
    }
    
    function startJourney(){
      if(!animateRunning){
        animateRunning = true;
        startButton.style.display='none';
        animate();
      }
    }
    startButton.addEventListener('click', startJourney);
    
    function navigateToNeuron(index){
      currentIndex = index;
      let target = points[index].position.clone();
      userPath.push(camera.position.clone());
      new TWEEN.Tween(camera.position)
        .to({x: target.x, y: target.y, z: target.z + 2000}, 2000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onUpdate(updateUserPath)
        .start();
    }
    
    function zoomOutToFit(){
      userPath.push(camera.position.clone());
      new TWEEN.Tween(camera.position)
        .to({x:0, y:5, z:5000}, 2000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onUpdate(updateUserPath)
        .start();
      currentIndex=-1;
    }
    
    let autopilotInterval;
    function toggleAutopilot(){
      autopilot = !autopilot;
      document.getElementById('autopilotStatus').innerText = autopilot?'ON':'OFF';
      if(autopilot){
        autopilotNavigate();
      } else {
        clearTimeout(autopilotInterval);
      }
    }
    
    function autopilotNavigate(){
      if(autopilot){
        clearTimeout(autopilotInterval);
        let index = Math.floor(Math.random()*points.length);
        navigateToNeuron(index);
        autopilotInterval = setTimeout(autopilotNavigate, 4000);
      }
    }
    
    function toggleHUD(){
      hudVisible=!hudVisible;
      document.getElementById('hud').style.display = hudVisible?'block':'none';
      document.getElementById('controlsOverlay').style.display = hudVisible?'block':'none';
    }
    
    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
      composer.setSize(window.innerWidth,window.innerHeight);
    }
    
    function onWheel(event){
      if(event.shiftKey){
        camera.fov += event.deltaY*0.05;
        camera.updateProjectionMatrix();
      } else {
        // גלילה בין נוירונים
        if(event.deltaY>0){
          currentIndex = (currentIndex+1)%points.length;
        } else {
          currentIndex = (currentIndex-1+points.length)%points.length;
        }
        navigateToNeuron(currentIndex);
      }
    }
    
    function onKeyDown(event){
      switch(event.key){
        case 'w': velocity.z -= 10*throttle; break;
        case 's': velocity.z += 10*throttle; break;
        case 'a': velocity.x -= 10*throttle; break;
        case 'd': velocity.x += 10*throttle; break;
        case 'ArrowUp': rotation.x += 0.01*throttle; break;
        case 'ArrowDown': rotation.x -= 0.01*throttle; break;
        case 'ArrowLeft': rotation.y += 0.01*throttle; break;
        case 'ArrowRight': rotation.y -= 0.01*throttle; break;
        case '+':
          throttle = Math.min(throttle+0.1, 10);
          document.getElementById('throttleValue').innerText = throttle.toFixed(1);
          break;
        case '-':
          throttle = Math.max(throttle-0.1, 0.1);
          document.getElementById('throttleValue').innerText = throttle.toFixed(1);
          break;
        case 't':
          toggleAutopilot(); 
          break;
        case 'h':
          toggleHUD(); 
          break;
        case 'Home':
          zoomOutToFit(); 
          break;
      }
    }
    
    // הפעלת הסצנה
    init();
  </script>
</body>
</html>
