<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>专  - 住爪 专拽转 V11.1 (拽专 转拽)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- General & Reset Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            background: linear-gradient(135deg, #1a1c20, #383b3e);
            font-family: 'Segoe UI', Arial, sans-serif;
            user-select: none;
            direction: rtl;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Top Controls Bar (Collapsible) --- */
        header.top-nav-controls {
            position: fixed; top: 0; left: 0; right: 0;
            background-color: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(5px);
            color: #fff;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 15px;
            border-bottom: 1px solid #444;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            flex-wrap: nowrap;
            min-height: 50px;
            transition: height 0.3s ease;
        }
        
        #mainNav {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            overflow: hidden;
        }

        #mainNav a {
            color: #fff; text-decoration: none; font-weight: bold; padding: 6px 12px;
            border-radius: 6px; font-size: 14px; transition: all 0.3s ease;
            cursor: pointer; border: 1px solid transparent;
            white-space: nowrap;
        }
        #mainNav a:hover { background-color: rgba(255, 221, 87, 0.2); border-color: rgba(255, 221, 87, 0.4); }
        #mainNav a.active { background-color: #ffdd57; color: #111; border-color: #ffdd57; transform: translateY(-1px); box-shadow: 0 2px 5px rgba(255, 221, 87, 0.3); }
        #mainNav a.off-screen {
            opacity: 0.5;
            color: #aaa;
        }
        #mainNav a.off-screen:hover {
            opacity: 1;
            background-color: rgba(170, 170, 170, 0.2);
            color: #ddd;
        }

        #controls-toggle {
            display: none; /* Hidden by default on large screens */
            background: none;
            border: 1px solid #888;
            border-radius: 5px;
            cursor: pointer;
            padding: 8px;
            margin-left: 10px;
        }
        #controls-toggle .bar {
            display: block;
            width: 22px;
            height: 2px;
            background-color: #fff;
            margin: 4px 0;
            transition: 0.4s;
        }

        #controls-wrapper {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .controls-separator { border-left: 1px solid #555; padding-left: 15px; margin-left: 0; }

        .controls-group { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 8px; }
        .controls-group label { font-size: 13px; color: #ccc; }
        .controls-group button, .controls-group select {
            padding: 6px 12px; background: rgba(255,255,255,0.1); color: #eee;
            border: 1px solid #666; border-radius: 6px; cursor: pointer; font-size: 13px;
            transition: all 0.2s ease;
        }
        .controls-group select option {
            background: #fff;
            color: #000;
        }
        .controls-group button:hover:not(:disabled) { background: rgba(255, 255, 255, 0.25); border-color: #888; }
        .controls-group button:disabled { background: rgba(255,255,255,0.05); color: #777; cursor: not-allowed; border-color: #444; }
        .controls-group button.active { background: #ffdd57; color: #111; border-color: #ffdd57; transform: translateY(-1px); box-shadow: 0 1px 4px rgba(255, 221, 87, 0.2); }
        .controls-group select:focus { outline: none; border-color: #ffdd57;}
        .controls-group input[type="range"] { width: 120px; }
        .vortex-controls { display: flex; align-items: center; gap: 8px; transition: all 0.5s ease; max-width: 0; opacity: 0; overflow: hidden; }
        .vortex-controls.visible { max-width: 200px; opacity: 1; }

        @media (max-width: 1200px) {
            header.top-nav-controls { flex-wrap: wrap; }
            #controls-toggle { display: block; }
            #controls-wrapper {
                display: none;
                flex-basis: 100%;
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding-top: 15px;
            }
            #controls-wrapper.open { display: flex; }
            .controls-separator { border-left: none; padding-left: 0; margin-left: 0; border-top: 1px solid #555; padding-top: 12px; }
            .controls-group { justify-content: space-between; }
        }


        /* --- Canvases & UI --- */
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #canvas { z-index: 1; background: transparent; }
        #hudContainer {
            position: fixed;
            top: 70px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: #ffc107;
            padding: 10px 15px;
            font-family: monospace;
            font-size: 13px;
            z-index: 1000;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: right;
            min-width: 220px;
            transition: top 0.3s ease;
        }
        #gravityCenterMarker {
            position: absolute; width: 24px; height: 24px;
            border: 3px solid rgba(255, 221, 87, 0.8);
            border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 5; pointer-events: none; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            background: radial-gradient(circle, rgba(255,221,87,0.4) 0%, rgba(255,221,87,0) 70%);
        }
        
        /* --- TICKER STYLES --- */
        #ticker-container{
            position:fixed;
            bottom:0;
            left:0;
            width:100%;
            height:50px;
            background:#1c1e21;
            color:#fff;
            border-top:1px solid #3e4042;
            display:flex;
            align-items:center;
            overflow:hidden;
            user-select:none;
            touch-action:pan-y;
            cursor:pointer; 
            z-index: 10001;
        }
        .ticker-label{
            background:#e4a80a;
            color:#1c1e21;
            padding:0 25px;
            font-weight:bold;
            font-size:18px;
            flex-shrink:0;
            height:100%;
            display:flex;
            align-items:center;
            z-index:2;
        }
        #ticker-canvas{
            flex-grow:1;
            height:100%;
            background:transparent;
        }
        
        /* --- POPUP STYLES --- */
        .popup-overlay{
            position:fixed;
            inset:0;
            background:rgba(0,0,0,.55);
            display:none;
            align-items:center;
            justify-content:center;
            z-index:10002;
        }
        .popup-box{
            background:#fff;
            color:#333;
            max-width:600px;
            padding:30px;
            border-radius:8px;
            box-shadow:0 4px 20px rgba(0,0,0,.3);
            font-size:18px;
            line-height:1.6;
            direction:rtl;
            position:relative;
        }
        .popup-close{
            position:absolute;
            top:10px;
            left:10px;
            font-size:24px;
            font-weight:bold;
            color:#999;
            cursor:pointer;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>

    <header class="top-nav-controls">
        <nav id="mainNav"></nav>
        <button id="controls-toggle">
            <span class="bar"></span><span class="bar"></span><span class="bar"></span>
        </button>
        <div id="controls-wrapper">
            <div class="controls-group controls-separator">
                <label for="layout-select">驻专住:</label>
                <select id="layout-select">
                    <option value="circle">注</option>
                    <option value="grid-4x2">专砖转 4x2</option>
                    <option value="grid-2x4">专砖转 2x4</option>
                    <option value="horizontal">驻拽</option>
                    <option value="vertical"></option>
                </select>
            </div>
            <div class="controls-group controls-separator">
                <button id="toggleWallsBtn">转: ON</button>
                <button id="toggleMagnetBtn">: ON</button>
                <button id="toggleWanderBtn">砖: OFF</button>
                <button id="toggleOrbitBtn">住: OFF</button>
                <button id="earthquakeBtn">专注转 </button>
                <button id="windBtn">砖 专</button>
            </div>
            <div class="controls-group controls-separator">
                <label for="gravity-select">拽专转 注:</label>
                <select id="gravity-select">
                    <option value="none"></option>
                    <option value="down"> </option>
                    <option value="center"> 专</option>
                    <option value="vortex">注专转</option>
                </select>
                <div id="vortex-controls" class="vortex-controls">
                    <label for="vortex-slider">注爪:</label>
                    <input type="range" id="vortex-slider" min="-100" max="100" value="0">
                </div>
            </div>
        </div>
    </header>

    <canvas id="canvas"></canvas>
    <div id="hudContainer">
        <div id="zoomInfo">: 1.00x</div>
        <div id="cameraPos"></div>
        <div id="viewBounds"></div>
        <div id="objectCount"></div>
        <div id="physicsStatus"></div>
        <div id="mouseCoords"></div>
        <div id="fpsDisplay"></div>
        <div id="energyDisplay"></div>
    </div>
    <div id="gravityCenterMarker"></div>

    <div id="ticker-container">
        <div class="ticker-label">拽</div>
        <canvas id="ticker-canvas"></canvas>
    </div>
    <div class="popup-overlay" id="popup">
        <div class="popup-box">
            <span class="popup-close" id="popup-close"></span>
            <p id="popup-content"></p>
        </div>
    </div>

    <script>
    // =========================================
    // 1. Constants & Global Variables
    // =========================================
    // Core Elements & State
    let canvas, ctx, keyCubes = [], springs = [];
    let worldMouse = { x: 0, y: 0 }, screenMouse = { x: 0, y: 0 }, isMouseDown = false, draggedCube = null;
    let clickStartTime = 0, clickStartPos = {x:0, y:0};
    let lastTimestamp = 0, worldWidth, worldHeight, currentStarId = 'star-home', expandedCube = null, followedCube = null;
    let headerHeight = 70;

    // Viewport
    let view = { x: 0, y: 0, scale: 1.0, targetScale: 1.0, targetX: 0, targetY: 0, isAnimating: false };
    const MIN_SCALE = 0.05, MAX_SCALE = 8.0, ZOOM_SENSITIVITY = 0.001, CLICK_THRESHOLD_DIST = 10, CLICK_THRESHOLD_TIME = 300;
    let viewportAnimation = null;
    let isPanning = false; let lastPanPos = { x: 0, y: 0 };
    let lastNavCheck = 0; 

    // Physics & World Control
    const friction = 0.92; const baseSpringK = 0.02, starSpringK = 0.03, interStarSpringK = 0.005, MAX_VELOCITY = 150;
    let boundariesEnabled = true, magnetEnabled = true, wanderEnabled = false, orbitEnabled = false;
    let layoutMode = 'circle', gravityMode = 'none', vortexStrength = 0;
    let gravityCenter = { x: 0, y: 0 };

    // Interactive Forces & HUD Stats
    let earthquakeLevel = 0, windLevel = 0, lastEarthquakeClick = 0;
    let frameCount = 0, lastFpsUpdate = 0, fps = 0, totalKineticEnergy = 0;

    // Ticker & Idle Mode
    let addTickerMessage; 
    let idleTimeout, demoInterval; const IDLE_TIME_MS = 15000;

    const cubeData = [
        { id: "star-home", text: "专砖", type: 'star', weight: 50 }, { id: "star-about", text: "转", type: 'star', weight: 45 }, { id: "star-skills", text: "转", type: 'star', weight: 80 }, { id: "star-platforms", text: "驻驻专转", type: 'star', weight: 70 }, { id: "star-live", text: "砖专转 Live", type: 'star', weight: 75 }, { id: "star-content", text: "住 转", type: 'star', weight: 60 }, { id: "star-contact", text: "爪专 拽砖专", type: 'star', weight: 30 },
        { id: "welcome", text: "专 ", type: 'card', parentId: 'star-home', weight: 10 }, { id: "explore", text: "拽专 转 转专", type: 'card', parentId: 'star-home', weight: 12 },
        { id: "orian", text: " ?", type: 'card', parentId: 'star-about', weight: 20 }, { id: "psycho", text: "PsychoFlash", type: 'card', parentId: 'star-about', weight: 18 }, { id: "volunteer", text: "转转", type: 'card', parentId: 'star-about', weight: 15 },
        { id: "ps", text: "Photoshop", type: 'skill', parentId: 'star-skills', weight: 10 }, { id: "ae", text: "After Effects", type: 'skill', parentId: 'star-skills', weight: 10 }, { id: "pr", text: "Premiere Pro", type: 'skill', parentId: 'star-skills', weight: 8 }, { id: "animate", text: "Animate", type: 'skill', parentId: 'star-skills', weight: 7 }, { id: "webdev", text: "Web Dev", type: 'skill', parentId: 'star-skills', weight: 15 },
        { id: "vmix", text: "Vmix Coding", type: 'live', parentId: 'star-live', weight: 22, youtubeId: 'B7_34tBi8eA' }, 
        { id: "techConsult", text: "Tech Consulting", type: 'live', parentId: 'star-live', weight: 19 },
        { id: "email", text: "", type: 'contact', parentId: 'star-contact', weight: 5 }, { id: "phone", text: "驻", type: 'contact', parentId: 'star-contact', weight: 5 }, { id: "facebook", text: "驻住拽", type: 'contact', parentId: 'star-contact', weight: 5 },
    ];

    // =========================================
    // 2. Utility Functions
    // =========================================
    function clamp(v, minv, maxv) { return Math.max(minv, Math.min(maxv, v)); }
    function screenToWorld(screenX, screenY) { return { x: view.x + screenX / view.scale, y: view.y + screenY / view.scale }; }
    function worldToScreen(worldX, worldY) { return { x: (worldX - view.x) * view.scale, y: (worldY - view.y) * view.scale }; }
    function getBoundingBox(cubes) {
        if (!cubes || cubes.length === 0) return null;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        cubes.forEach(c => {
            minX = Math.min(minX, c.x - c.width / 2);
            minY = Math.min(minY, c.y - c.height / 2);
            maxX = Math.max(maxX, c.x + c.width / 2);
            maxY = Math.max(maxY, c.y + c.height / 2);
        });
        return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
    }

    // =========================================
    // 3. Core Classes (KeyCube, Spring)
    // =========================================
    class KeyCube {
        constructor(id, text, type, parentId = null, weight = 10, youtubeId = null) {
            this.id = id; this.text = text; this.type = type; this.isStar = (type === 'star'); this.weight = weight; this.youtubeId = youtubeId;
            this.parentId = parentId;
            this.x = Math.random() * worldWidth; this.y = Math.random() * worldHeight;
            this.vx = 0; this.vy = 0;
            this.gridX = this.x; this.gridY = this.y;
            this.baseWidth = this.isStar ? 250 : 150; this.baseHeight = this.isStar ? 150 : 100;
            this.width = this.baseWidth; this.height = this.baseHeight;
            this.color = this.getColorByType(type); this.textColor = "#ffffff";
            this.dragging = false;
            this.mass = this.isStar ? this.weight / 1.5 : this.weight / 5;
            this.isExpanded = false; this.expandProgress = 0;
            this.lastRepulsionForce = {x:0, y:0};
            this.closeButtonRect = null;
        }

        getColorByType(type) {
            switch (type) { case 'star': return 'rgba(255, 220, 80, 0.9)'; case 'skill': return 'rgba(255, 152, 0, 0.8)'; case 'live': return 'rgba(233, 30, 99, 0.8)'; case 'contact': return 'rgba(60, 80, 200, 0.8)'; default: return 'rgba(120, 120, 120, 0.8)'; }
        }
        applyForce(fx, fy) { this.vx += fx / this.mass; this.vy += fy / this.mass; }
        update(dt) {
            const expandSpeed = 0.1;
            if (this.isExpanded) { this.expandProgress = Math.min(1, this.expandProgress + expandSpeed); }
            else { this.expandProgress = Math.max(0, this.expandProgress - expandSpeed); }

            const targetWidth = this.isExpanded ? (canvas.width / view.scale * 0.9) : this.baseWidth;
            const targetHeight = this.isExpanded ? (canvas.height / view.scale * 0.8) : this.baseHeight;
            this.width += (targetWidth - this.width) * expandSpeed;
            this.height += (targetHeight - this.height) * expandSpeed;

            if (this.isExpanded) {
                const targetScreenY = headerHeight + (canvas.height - headerHeight) / 2;
                const targetPos = screenToWorld(canvas.width / 2, targetScreenY);
                this.x += (targetPos.x - this.x) * 0.2; this.y += (targetPos.y - this.y) * 0.2;
                this.vx *= 0.1; this.vy *= 0.1;
                return;
            }

            if(!this.dragging) {
                if (magnetEnabled) {
                    const dx = this.gridX - this.x; const dy = this.gridY - this.y;
                    const effStr = this.isStar ? 0.05 * 1.5 : 0.05; this.applyForce(dx * effStr, dy * effStr);
                }
                if (wanderEnabled) {
                    const wf = this.isStar ? 1.2 : 1.0;
                    const wanderImpulse = 0.6 * wf;
                    this.applyForce((Math.random()-0.5) * wanderImpulse, (Math.random()-0.5) * wanderImpulse);
                }

                const isOrbiting = orbitEnabled && !this.isStar && this.parentId;
                if (isOrbiting) {
                    const parent = keyCubes.find(c => c.id === this.parentId);
                    if (parent && !parent.isExpanded) {
                        const odx = parent.x - this.x; const ody = parent.y - this.y;
                        const odist = Math.hypot(odx, ody);
                        if(odist > 1) {
                            const strength = 0.5 + (vortexStrength / 100) * 0.6;
                            this.applyForce(ody / odist * strength, -odx / odist * strength);
                        }
                    }
                } else {
                    switch(gravityMode) {
                        case 'down': this.applyForce(0, 1.8 * this.mass); break;
                        case 'center':
                            const dx = gravityCenter.x - this.x; const dy = gravityCenter.y - this.y;
                            this.applyForce(dx * 0.01, dy * 0.01);
                            break;
                        case 'vortex':
                            const vdx = gravityCenter.x - this.x; const vdy = gravityCenter.y - this.y;
                            const vdist = Math.hypot(vdx, vdy);
                            if (vdist > 10) {
                                const tangentialStrength = (vortexStrength / 100) * 350;
                                this.applyForce(vdy / vdist * tangentialStrength, -vdx / vdist * tangentialStrength);
                                const pullStrength = 0.02 * (Math.abs(vortexStrength) / 100 + 0.1);
                                this.applyForce(vdx * pullStrength, vdy * pullStrength);
                            }
                            break;
                    }
                }
            }

            if(this.dragging) {
                this.x = worldMouse.x; this.y = worldMouse.y;
                this.vx = 0; this.vy = 0;
            } else {
                this.vx = clamp(this.vx * friction, -MAX_VELOCITY, MAX_VELOCITY);
                this.vy = clamp(this.vy * friction, -MAX_VELOCITY, MAX_VELOCITY);
                this.x += this.vx * dt * 60; this.y += this.vy * dt * 60;
            }

            if (boundariesEnabled) {
                const r = 0.5; const hw = this.width/2; const hh = this.height/2;
                if (this.x < hw) { this.x = hw; this.vx *= -r; }
                else if (this.x > worldWidth - hw) { this.x = worldWidth - hw; this.vx *= -r; }
                if (this.y < hh) { this.y = hh; this.vy *= -r; }
                else if (this.y > worldHeight - hh) { this.y = worldHeight - hh; this.vy *= -r; }
            }
        }
        handleInteractions(others) {
            if (this.dragging || this.isExpanded) return;
            this.lastRepulsionForce = {x: 0, y: 0};
            others.forEach(other => {
                if (other === this || other.isExpanded) return;
                const dx = other.x - this.x; const dy = other.y - this.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 1) distSq=1;
                const minDist = (this.width + other.width) / 2 + 20;
                if (distSq < minDist * minDist) {
                    const dist = Math.sqrt(distSq);
                    const overlap = minDist - dist;
                    const force = overlap * 0.6;
                    const totalMass = this.mass + other.mass;
                    const forceX = -dx/dist*force*(other.mass/totalMass);
                    const forceY = -dy/dist*force*(other.mass/totalMass);
                    this.applyForce(forceX, forceY);
                    this.lastRepulsionForce.x += forceX;
                    this.lastRepulsionForce.y += forceY;
                }
            });
        }
        draw(ctx) {
            const halfW = this.width / 2, halfH = this.height / 2;
            const left = this.x - halfW, top = this.y - halfH;
            const alpha = ctx.globalAlpha;

            if (expandedCube && expandedCube !== this) {
                ctx.globalAlpha *= clamp((1 - expandedCube.expandProgress) * 0.5, 0, 1);
                if (ctx.globalAlpha < 0.01) { ctx.globalAlpha = alpha; return; }
            }

            if (this.expandProgress > 0) {
                ctx.save();
                ctx.globalAlpha = this.expandProgress;
                const expandedColor = this.getColorByType(this.type).replace(/[\d\.]+\)$/g, '0.97)');
                ctx.fillStyle = expandedColor;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 30 * this.expandProgress;
                ctx.beginPath();
                ctx.roundRect(left, top, this.width, this.height, [20]);
                ctx.fill();
                ctx.shadowColor = 'transparent';

                const padding = 30 * this.expandProgress;
                ctx.fillStyle = this.textColor;
                ctx.textAlign = "right";
                ctx.textBaseline = "top";
                let titleFontSize = clamp(this.height * 0.05, 20, 40) * this.expandProgress;
                ctx.font = `bold ${titleFontSize}px Arial`;
                ctx.fillText(this.text, left + this.width - padding, top + padding);
                
                if (this.youtubeId && this.expandProgress > 0.8) {
                    const videoY = top + padding + titleFontSize + 20;
                    const videoHeight = this.height - (padding * 2) - titleFontSize - 30;
                    const videoWidth = videoHeight * 16 / 9;
                    const videoX = left + (this.width - videoWidth) / 2;
                    
                    ctx.save();
                    ctx.globalAlpha = (this.expandProgress - 0.8) / 0.2;
                    ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                    ctx.beginPath();
                    ctx.roundRect(videoX, videoY, videoWidth, videoHeight, [10]);
                    ctx.fill();
                    
                    ctx.fillStyle = "#FFF";
                    ctx.beginPath();
                    const iconSize = Math.min(60, videoHeight * 0.4);
                    const centerX = videoX + videoWidth/2;
                    const centerY = videoY + videoHeight/2;
                    ctx.moveTo(centerX - iconSize/2, centerY - iconSize/2);
                    ctx.lineTo(centerX - iconSize/2, centerY + iconSize/2);
                    ctx.lineTo(centerX + iconSize/2, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                const closeBtnSize = 35 * this.expandProgress;
                this.closeButtonRect = { x: left + padding - (closeBtnSize/2), y: top + padding, w: closeBtnSize, h: closeBtnSize };
                ctx.fillStyle = 'rgba(233, 30, 99, 0.9)';
                ctx.beginPath();
                ctx.roundRect(this.closeButtonRect.x, this.closeButtonRect.y, closeBtnSize, closeBtnSize, [8]);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                const margin = 10 * this.expandProgress;
                ctx.moveTo(this.closeButtonRect.x + margin, this.closeButtonRect.y + margin);
                ctx.lineTo(this.closeButtonRect.x + closeBtnSize - margin, this.closeButtonRect.y + closeBtnSize - margin);
                ctx.moveTo(this.closeButtonRect.x + closeBtnSize - margin, this.closeButtonRect.y + margin);
                ctx.lineTo(this.closeButtonRect.x + margin, this.closeButtonRect.y + closeBtnSize - margin);
                ctx.stroke();

                ctx.restore();
                if (this.expandProgress >= 1.0) { ctx.globalAlpha = alpha; return; }
            }

            ctx.save();
            ctx.globalAlpha = ctx.globalAlpha * (1 - this.expandProgress);
            if (ctx.globalAlpha > 0.01) {
                const br = this.isStar ? 15 : 10;
                ctx.fillStyle = this.color;
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 10;
                ctx.beginPath(); ctx.roundRect(left, top, this.width, this.height, [br]); ctx.fill();
                ctx.shadowColor = 'transparent';

                ctx.fillStyle=this.textColor;
                ctx.textAlign="center"; ctx.textBaseline="middle";
                let fs = clamp(this.width/(this.isStar?4:5), 10, this.isStar?40:24);
                ctx.font=`bold ${fs}px Arial`;
                ctx.fillText(this.text,this.x,this.y);

                if (this.dragging){
                    ctx.strokeStyle="rgba(255,255,0,0.9)"; ctx.lineWidth=4;
                    ctx.beginPath(); ctx.roundRect(left,top,this.width,this.height,[br]); ctx.stroke();
                }
            }
            ctx.restore();
            ctx.globalAlpha = alpha;
        }

        isPointInside(px, py) { return px >= this.x - this.width/2 && px <= this.x + this.width/2 && py >= this.y - this.height/2 && py <= this.y + this.height/2; }
        isCloseButtonHit(worldX, worldY) {
            if (!this.isExpanded || !this.closeButtonRect) return false;
            const rect = this.closeButtonRect;
            return worldX >= rect.x && worldX <= rect.x + rect.w &&
                   worldY >= rect.y && worldY <= rect.y + rect.h;
        }
    }

    class Spring {
        constructor(cA, cB, rL, s){this.cubeA=cA;this.cubeB=cB;this.restLength=rL;this.stiffness=s;this.damping=0.15;}
        update(){
            if(!this.cubeA || !this.cubeB || this.cubeA.isExpanded || this.cubeB.isExpanded) return;
            const dx=this.cubeB.x-this.cubeA.x;const dy=this.cubeB.y-this.cubeA.y;let d=Math.hypot(dx,dy);if(d<1)d=1;
            const disp=d-this.restLength;const sFm=disp*this.stiffness;
            const rVx=this.cubeB.vx-this.cubeA.vx;const rVy=this.cubeB.vy-this.cubeA.vy;
            const vAS=(rVx*dx+rVy*dy)/d;const dFm=vAS*this.damping;
            const tFm=sFm+dFm;
            const fX=(dx/d)*tFm;const fY=(dy/d)*tFm;
            if(!this.cubeA.dragging)this.cubeA.applyForce(fX,fY);
            if(!this.cubeB.dragging)this.cubeB.applyForce(-fX,-fY);
        }
        draw(ctx){
            if(!this.cubeA || !this.cubeB || this.cubeA.isExpanded || this.cubeB.isExpanded || expandedCube) return;
            const alpha = Math.max(0, 1 - this.cubeA.expandProgress) * Math.max(0, 1 - this.cubeB.expandProgress);
            if (alpha < 0.1) return;
            ctx.beginPath(); ctx.moveTo(this.cubeA.x, this.cubeA.y); ctx.lineTo(this.cubeB.x, this.cubeB.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.12 * alpha})`; ctx.lineWidth = 1.5; ctx.stroke();
        }
    }

    // =========================================
    // 4. Setup & Initialization Functions
    // =========================================
    function init() {
        canvas = document.getElementById('canvas'); ctx = canvas.getContext('2d');
        setupWorld();
        gravityCenter = { x: worldWidth / 2, y: worldHeight / 2};
        keyCubes = cubeData.map(item => new KeyCube(item.id, item.text, item.type, item.parentId, item.weight, item.youtubeId));
        populateNav();
        resetPhysics(true);
        initEnhancedTicker(); // Initialize the new ticker
        setupEventListeners();
        updateAllButtonStates();
        const homeStar = keyCubes.find(c => c.id === 'star-home');
        if (homeStar) { centerViewOn(homeStar.x, homeStar.y, 0.8, true); setActiveNav('star-home'); }
        resetIdleTimer();
        lastTimestamp = performance.now();
        requestAnimationFrame(animate);
    }

    function setupWorld() { worldWidth = 5000; worldHeight = 5000; resizeCanvas(); }

    function populateNav() {
        const navElement = document.getElementById('mainNav');
        navElement.innerHTML = '';
        keyCubes.filter(cube => cube.isStar).forEach(starCube => {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = starCube.text;
            link.setAttribute('data-target', starCube.id);
            link.onclick = (e) => { e.preventDefault(); navigateToStar(starCube.id); };
            navElement.appendChild(link);
        });
    }

    function setActiveNav(activeStarId) {
        if (!activeStarId || activeStarId === currentStarId) return;
        document.querySelectorAll('#mainNav a').forEach(link => {
            link.classList.toggle('active', link.getAttribute('data-target') === activeStarId);
        });
        currentStarId = activeStarId;
    }

    function resizeCanvas() { 
        if (!canvas) return; 
        canvas.width = window.innerWidth; 
        canvas.height = window.innerHeight;
        const header = document.querySelector('header.top-nav-controls');
        headerHeight = header ? header.offsetHeight : 70;
        document.getElementById('hudContainer').style.top = `${headerHeight + 15}px`;
    }

    function assignGridPositions() {
        switch(layoutMode) {
            case 'circle': assignGridPositionsCircle(); break;
            case 'grid-4x2': assignGridPositionsGrid(4, 2); break;
            case 'grid-2x4': assignGridPositionsGrid(2, 4); break;
            case 'horizontal': assignGridPositionsLine(true); break;
            case 'vertical': assignGridPositionsLine(false); break;
        }
    }
        
    function assignGridPositionsCircle() {
        const stars = keyCubes.filter(c => c.isStar);
        const starLayoutRadius = Math.min(worldWidth, worldHeight) * 0.35;
        const angleStepStar = (2 * Math.PI) / stars.length;
        stars.forEach((star, index) => {
            const angle = index * angleStepStar - Math.PI / 2;
            star.gridX = worldWidth / 2 + Math.cos(angle) * starLayoutRadius;
            star.gridY = worldHeight / 2 + Math.sin(angle) * starLayoutRadius;
            setChildCardPositions(star);
        });
    }

    function assignGridPositionsGrid(cols, rows) {
        const stars = keyCubes.filter(c => c.isStar);
        const padding = 1000;
        const cellWidth = (worldWidth - padding) / cols;
        const cellHeight = (worldHeight - padding) / rows;
        stars.forEach((star, i) => {
            const col = i % cols;
            const row = Math.floor(i / cols);
            star.gridX = (col + 0.5) * cellWidth + padding / 2;
            star.gridY = (row + 0.5) * cellHeight + padding / 2;
            setChildCardPositions(star);
        });
    }

    function assignGridPositionsLine(isHorizontal) {
        const stars = keyCubes.filter(c => c.isStar);
        const padding = 1000;
        const count = stars.length || 1;
        const step = isHorizontal ? (worldWidth - padding) / count : (worldHeight - padding) / count;
        stars.forEach((star, i) => {
            star.gridX = isHorizontal ? (i + 0.5) * step + padding/2 : worldWidth / 2;
            star.gridY = isHorizontal ? worldHeight / 2 : (i + 0.5) * step + padding/2;
            setChildCardPositions(star);
        });
    }

    function setChildCardPositions(star) {
        const childCards = keyCubes.filter(c => c.parentId === star.id);
        if (childCards.length === 0) return;
        const angleStepCard = (2 * Math.PI) / childCards.length;
        childCards.forEach((card, index) => {
            const angle = index * angleStepCard;
            const baseDist = 150 + (star.weight * 1.5) + (card.weight * 4);
            const r = baseDist * (0.9 + Math.random() * 0.2);
            card.gridX = star.gridX + Math.cos(angle) * r;
            card.gridY = star.gridY + Math.sin(angle) * r;
        });
    }

    function buildSprings() {
        springs = [];
        const stars = keyCubes.filter(c => c.isStar);
        keyCubes.forEach(card => {
            if (!card.isStar && card.parentId) {
                const parentStar = keyCubes.find(c => c.id === card.parentId);
                if (parentStar) {
                    const baseDist = 150 + (parentStar.weight * 1.5) + (card.weight * 8);
                    const restLength = baseDist * (0.9 + Math.random() * 0.2);
                    springs.push(new Spring(card, parentStar, restLength, starSpringK));
                }
            }
        });
        for (let i = 0; i < stars.length; i++) {
            for (let j = i + 1; j < stars.length; j++) {
                const starA = stars[i]; const starB = stars[j];
                const restLength = Math.hypot(starB.gridX - starA.gridX, starB.gridY - starA.gridY);
                springs.push(new Spring(starA, starB, restLength, interStarSpringK));
            }
        }
    }

    // =========================================
    // 5. Viewport Control & Navigation
    // =========================================
    function centerViewOn(worldX, worldY, targetScale = view.targetScale, immediate = false, onComplete) {
        setFollowedCube(null);
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); }
        view.targetScale = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        view.targetX = worldX - (canvas.width / (2 * view.targetScale));
        view.targetY = worldY - ((headerHeight / view.targetScale) + (canvas.height - (headerHeight / view.targetScale)) / 2);
        
        if (immediate) {
            view.x = view.targetX; view.y = view.targetY; view.scale = view.targetScale;
            view.isAnimating = false; 
            updateZoomInfo();
            if (onComplete) onComplete();
        } else { animateViewport(onComplete); }
    }

    function navigateToStar(starId) {
        if (followedCube && followedCube.id === starId) return;
        if(expandedCube) { expandedCube.isExpanded = false; expandedCube = null; }
        
        const starCube = keyCubes.find(c => c.id === starId);
        if (!starCube) return;
        
        setActiveNav(starId);
        setFollowedCube(starCube);
    }
    
    function setFollowedCube(cube) {
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); }
        if (followedCube && !cube) {
             addTickerMessage(`注拽 住转 专: ${followedCube.text}`, { color: '#ff9800', icon: '' });
        }
        followedCube = cube;
        if (cube) {
            addTickerMessage(`注拽 专: ${cube.text}`, { color: '#03a9f4', icon: '' });
        }
    }

    function animateViewport(onCompleteCallback) {
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); }
        view.isAnimating = true;
        viewportAnimation = gsap.to(view, {
            duration: 1.2, x: view.targetX, y: view.targetY, scale: view.targetScale,
            ease: "power3.inOut",
            onUpdate: updateZoomInfo,
            onComplete: () => { 
                view.isAnimating = false; 
                viewportAnimation = null; 
                if (onCompleteCallback) onCompleteCallback();
            },
            onInterrupt: () => { 
                view.isAnimating = false; 
                viewportAnimation = null;
                view.targetX = view.x; view.targetY = view.y; view.targetScale = view.scale; 
                setFollowedCube(null);
            }
        });
    }

    function updateZoomInfo() {
        const el = document.getElementById('zoomInfo');
        if(el) el.textContent = `: ${view.scale.toFixed(2)}x`;
    }


    // =========================================
    // 6. Event Listeners & Interaction
    // =========================================
    function setupEventListeners() {
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        window.addEventListener('resize', setupWorld);

        document.getElementById('controls-toggle').addEventListener('click', (e) => {
            e.currentTarget.classList.toggle('open');
            document.getElementById('controls-wrapper').classList.toggle('open');
            setTimeout(resizeCanvas, 350); 
        });

        document.getElementById('layout-select').addEventListener('change', (e) => {
            setFollowedCube(null);
            layoutMode = e.target.value;
            assignGridPositions();
            buildSprings();
        });

        document.getElementById('toggleWallsBtn')?.addEventListener('click', () => { boundariesEnabled = !boundariesEnabled; updateAllButtonStates();});
        document.getElementById('toggleMagnetBtn')?.addEventListener('click', () => { magnetEnabled = !magnetEnabled; updateAllButtonStates();});
        document.getElementById('toggleWanderBtn')?.addEventListener('click', () => { wanderEnabled = !wanderEnabled; updateAllButtonStates();});
        document.getElementById('toggleOrbitBtn')?.addEventListener('click', () => { orbitEnabled = !orbitEnabled; updateAllButtonStates();});
        
        document.getElementById('earthquakeBtn')?.addEventListener('click', () => {
            earthquakeLevel++;
            const strength = (180 + (Math.random() - 0.5) * 80) * earthquakeLevel;
            keyCubes.forEach(cube => {
                if (!cube.dragging && !cube.isExpanded) {
                    const angle = Math.random() * Math.PI * 2;
                    cube.applyForce(Math.cos(angle) * strength, Math.sin(angle) * strength + (cube.mass * -45));
                }
            });
            setTimeout(() => earthquakeLevel = Math.max(0, earthquakeLevel - 1), 6000);
        });

        document.getElementById('windBtn')?.addEventListener('click', () => {
            windLevel++;
            const duration = 2000 + windLevel * 800;
            const baseStrength = 12.0 * windLevel * (0.8 + Math.random() * 0.4);
            const angle = Math.random() * Math.PI * 2;
            const windForce = { x: Math.cos(angle) * baseStrength, y: Math.sin(angle) * baseStrength };
            let windInterval = setInterval(() => {
                keyCubes.forEach(cube => {
                    if (!cube.dragging && !cube.isExpanded) cube.applyForce(windForce.x * (Math.random() * 0.5 + 0.5), windForce.y * (Math.random() * 0.5 + 0.5));
                });
            }, 100);
            setTimeout(() => { clearInterval(windInterval); windLevel = Math.max(0, windLevel - 1); }, duration);
        });

        document.getElementById('gravity-select').addEventListener('change', (e) => {
            gravityMode = e.target.value;
            document.getElementById('vortex-controls').classList.toggle('visible', gravityMode === 'vortex');
            updateGravityCenterMarker();
        });
        document.getElementById('vortex-slider').addEventListener('input', (e) => { vortexStrength = parseInt(e.target.value, 10); });

        ['mousedown', 'mousemove', 'wheel', 'keydown', 'touchstart'].forEach(evt => document.addEventListener(evt, resetIdleTimer, false));
    }

    function updateAllButtonStates() {
        document.getElementById('toggleWallsBtn').textContent = `转: ${boundariesEnabled ? 'ON' : 'OFF'}`;
        document.getElementById('toggleWallsBtn').classList.toggle('active', boundariesEnabled);
        document.getElementById('toggleMagnetBtn').textContent = `: ${magnetEnabled ? 'ON' : 'OFF'}`;
        document.getElementById('toggleMagnetBtn').classList.toggle('active', magnetEnabled);
        document.getElementById('toggleWanderBtn').textContent = `砖: ${wanderEnabled ? 'ON' : 'OFF'}`;
        document.getElementById('toggleWanderBtn').classList.toggle('active', wanderEnabled);
        document.getElementById('toggleOrbitBtn').textContent = `住: ${orbitEnabled ? 'ON' : 'OFF'}`;
        document.getElementById('toggleOrbitBtn').classList.toggle('active', orbitEnabled);
    }

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    function onPointerDown(e) {
        isMouseDown = true;
        const pos = getEventPos(e);
        screenMouse = pos;
        worldMouse = screenToWorld(pos.x, pos.y);
        clickStartTime = performance.now();
        clickStartPos = { ...worldMouse };
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); }
        draggedCube = null; isPanning = false;

        if (expandedCube) {
            if (expandedCube.isCloseButtonHit(worldMouse.x, worldMouse.y)) {
                expandedCube.isExpanded = false; expandedCube = null;
            }
            isMouseDown = false; return;
        }

        for (let i = keyCubes.length - 1; i >= 0; i--) {
            const cube = keyCubes[i];
            if (cube.isPointInside(worldMouse.x, worldMouse.y)) {
                draggedCube = cube;
                cube.dragging = true;
                keyCubes.splice(i, 1); keyCubes.push(draggedCube);
                break;
            }
        }
        if (!draggedCube && !expandedCube) { 
            isPanning = true; 
            lastPanPos = { ...screenMouse }; 
            if(followedCube) setFollowedCube(null);
        }
    }

    function onPointerMove(e) {
        if (!isMouseDown || expandedCube) return;
        const pos = getEventPos(e); screenMouse = pos;
        worldMouse = screenToWorld(pos.x, pos.y);
        if (isPanning) {
            if(followedCube) setFollowedCube(null);
            const dx = pos.x - lastPanPos.x; const dy = pos.y - lastPanPos.y;
            view.x -= dx / view.scale; view.y -= dy / view.scale;
            view.targetX = view.x; view.targetY = view.y;
        }
        lastPanPos = pos;
    }

    function onPointerUp(e) {
        if (!isMouseDown) return;
        isMouseDown = false;
        const timeHeld = performance.now() - clickStartTime;
        const distMoved = Math.hypot(worldMouse.x - clickStartPos.x, worldMouse.y - clickStartPos.y);

        if (expandedCube) {
            if (!expandedCube.isPointInside(worldMouse.x, worldMouse.y) && !expandedCube.isCloseButtonHit(worldMouse.x, worldMouse.y)) {
                expandedCube.isExpanded = false; expandedCube = null;
            }
        } else if (draggedCube) {
            draggedCube.dragging = false;
            if (distMoved < CLICK_THRESHOLD_DIST && timeHeld < CLICK_THRESHOLD_TIME) { handleCubeClick(draggedCube); }
        } else if (isPanning && distMoved < CLICK_THRESHOLD_DIST && timeHeld < CLICK_THRESHOLD_TIME) {
             const distToCenter = Math.hypot(worldMouse.x - gravityCenter.x, worldMouse.y - gravityCenter.y);
            const clickRadius = 50 / view.scale; // 50px radius in screen space

            if ((gravityMode === 'vortex' || gravityMode === 'center') && distToCenter < clickRadius) {
                createRippleEffect(gravityCenter.x, gravityCenter.y);
            } else {
                gravityCenter = { ...worldMouse };
                updateGravityCenterMarker();
            }
        }
        draggedCube = null; isPanning = false;
    }

    function onWheel(e) {
        e.preventDefault();
        if (followedCube) setFollowedCube(null);
        if (expandedCube) return;
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); }
        const wheelDelta = e.deltaY;
        const zoomFactor = Math.exp(-wheelDelta * ZOOM_SENSITIVITY);
        const mouseWorldBefore = screenToWorld(screenMouse.x, screenMouse.y);
        view.scale = clamp(view.scale * zoomFactor, MIN_SCALE, MAX_SCALE);
        view.x = mouseWorldBefore.x - (screenMouse.x / view.scale);
        view.y = mouseWorldBefore.y - (screenMouse.y / view.scale);
        view.targetX = view.x; view.targetY = view.y; view.targetScale = view.scale;
        updateZoomInfo();
    }

    function updateGravityCenterMarker() {
        const marker = document.getElementById('gravityCenterMarker');
        if(gravityMode === 'center' || gravityMode === 'vortex') {
            const screenPos = worldToScreen(gravityCenter.x, gravityCenter.y);
            marker.style.left = `${screenPos.x}px`;
            marker.style.top = `${screenPos.y}px`;
            marker.style.opacity = '1';
            const scale = clamp(1 / view.scale, 0.5, 2);
            marker.style.transform = `translate(-50%, -50%) scale(${scale})`;
        } else { marker.style.opacity = '0'; }
    }
    
    function createRippleEffect(originX, originY) {
        addTickerMessage(' 专 !', { 
            color: '#2196F3', 
            icon: '',
            onClickAction: () => {
                createRippleEffect(originX, originY);
            }
        });
        const rippleStrength = 40000; 
        keyCubes.forEach(cube => {
            if (cube.isExpanded) return;
            const dx = cube.x - originX;
            const dy = cube.y - originY;
            const dist = Math.hypot(dx, dy);

            if (dist < 1) return; 

            // Force weakens with distance
            const force = rippleStrength / (dist + 50); 
            const forceX = (dx / dist) * force;
            const forceY = (dy / dist) * force;

            cube.applyForce(forceX, forceY);
        });
    }

    // =========================================
    // 7. Cube Content & Click Handling
    // =========================================
    function handleCubeClick(cube) {
        if (cube.isStar) { 
            navigateToStar(cube.id); 
        } else {
            if (followedCube) setFollowedCube(null);
            if (expandedCube) expandedCube.isExpanded = false;
            expandedCube = cube; cube.isExpanded = true;
            centerViewOn(cube.x, cube.y, view.scale); 
        }
    }
    
    // =========================================
    // 8. Physics & Viewport Helpers
    // =========================================
    function resetPhysics(hardReset=false) {
        if(followedCube) setFollowedCube(null);
        if(expandedCube){expandedCube.isExpanded=false;expandedCube=null;} 
        assignGridPositions(); 
        buildSprings();
        if(hardReset)keyCubes.forEach(c=>{c.x=c.gridX+(Math.random()-.5)*10;c.y=c.gridY+(Math.random()-.5)*10;c.vx=0;c.vy=0;c.dragging=false;});
    }

    function updateActiveNavFromView() {
        if (isPanning || isMouseDown || view.isAnimating || expandedCube || followedCube) return;
        const viewCenterX = canvas.width / 2;
        const viewCenterY = headerHeight + (canvas.height - headerHeight) / 2;
        let closestStar = null;
        let minDistance = Infinity;

        keyCubes.filter(c => c.isStar).forEach(star => {
            const screenPos = worldToScreen(star.x, star.y);
            if (screenPos.x > 0 && screenPos.x < canvas.width && screenPos.y > headerHeight && screenPos.y < canvas.height) {
                const distance = Math.hypot(screenPos.x - viewCenterX, screenPos.y - viewCenterY);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestStar = star;
                }
            }
        });

        if (closestStar && closestStar.id !== currentStarId) {
            if (minDistance < Math.min(canvas.width, canvas.height) * 0.35) {
                 setActiveNav(closestStar.id);
            }
        }
    }
    
    function updateNavItemsState() {
        const navElement = document.getElementById('mainNav');
        if (navElement.children.length === 0) populateNav();

        const viewTopLeft = screenToWorld(0, 0);
        const viewBottomRight = screenToWorld(canvas.width, canvas.height);

        navElement.querySelectorAll('a').forEach(link => {
            const star = keyCubes.find(c => c.id === link.dataset.target);
            if(star) {
                const isVisible = star.x + star.width/2 > viewTopLeft.x && star.x - star.width/2 < viewBottomRight.x && star.y + star.height/2 > viewTopLeft.y && star.y - star.height/2 < viewBottomRight.y;
                link.classList.toggle('off-screen', !isVisible);
            }
        });
    }

    // =========================================
    // 9. ENHANCED TICKER LOGIC
    // =========================================
    function initEnhancedTicker() {
        const canvas = document.getElementById('ticker-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('ticker-container');
        const label = container.querySelector('.ticker-label');
        const popup = document.getElementById('popup');
        const popupContent = document.getElementById('popup-content');
        const popupClose = document.getElementById('popup-close');

        const queue = [];
        const active = [];
        let isDrag = false, startX = 0, vel = 0, startT = 0, paused = false;
        let last = 0, running = false;
        const BASE_SPD = 60, MASK = 40, GAP = 0;
        let labelW = 0;
        
        function resize() {
            if (!label || !container || !canvas) return;
            labelW = label.clientWidth;
            canvas.width = container.clientWidth - labelW;
            canvas.height = container.clientHeight;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'right';
            ctx.direction = 'rtl';
        }
        window.addEventListener('resize', resize);
        resize();

        const ease = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        /**
         * Represents a single message in the ticker.
         */
        class Msg {
            constructor(text, options = {}) {
                this.src = text;
                this.opt = { 
                    color: '#fff', 
                    bold: false, 
                    hold: false,
                    details: null,
                    icon: null,          // NEW: Icon (e.g., emoji) to display next to the text
                    onClickAction: null, // NEW: Custom function to run on click
                    ...options 
                };
                
                this.displayText = this.opt.icon ? `${this.opt.icon} ${this.src}` : this.src;
                this._measure();
                this.x = -18;
                this.ease = false;
                this.sx = 0; this.tx = 0; this.es = 0; this.ed = 400;
                this.first = true;
                this.sep = this.src === '|';
            }
            _measure() { 
                ctx.font = `${this.opt.bold ? 'bold ' : ''}16px sans-serif`; 
                this.w = ctx.measureText(this.displayText).width + 36;
                this.tw = this.w - 36;
            }
            get right() { return this.x + 18; }
            get left() { return this.right - this.w; }
            start(tgt, now, d = 400) { this.ease = true; this.sx = this.x; this.tx = tgt; this.es = now; this.ed = d; }
            step(now) { const t = Math.min((now - this.es) / this.ed, 1); this.x = this.sx + (this.tx - this.sx) * ease(t); if (t >= 1) this.ease = false; }
            extended() { return this.opt.details || this.src; }
        }
        
        /**
         * The main public function to add a new message to the ticker.
         */
        addTickerMessage = (text, options) => {
            // Prevent adding empty, null, or non-string messages
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return;
            }
            // Prevent adding a message if it's identical to the last one queued
            const lastQueued = queue.length > 0 ? queue[queue.length - 1] : null;
            if (lastQueued && lastQueued.text === text) {
                return;
            }
            queue.push({ text, options });
            if (!running) start();
        };

        // --- Interaction Listeners ---
        const ptrX = e => e.clientX ?? e.touches[0].clientX;
        const shift = dx => active.forEach(m => m.x += dx);
        container.addEventListener('wheel', e => { shift(-(e.deltaY || e.deltaX)); e.preventDefault(); }, { passive: false });
        container.addEventListener('pointerdown', e => { isDrag = true; vel = 0; startX = ptrX(e); startT = e.timeStamp; container.setPointerCapture(e.pointerId); });
        const endDrag = e => { if (!isDrag) return; isDrag = false; container.releasePointerCapture(e.pointerId); };
        container.addEventListener('pointerup', endDrag);
        container.addEventListener('pointercancel', endDrag);
        container.addEventListener('pointermove', e => { if (isDrag) { const x = ptrX(e), dx = x - startX; shift(dx); const dt = e.timeStamp - startT; if (dt > 0) vel = dx / dt; startX = x; startT = e.timeStamp; } });
        container.addEventListener('pointerenter', () => paused = true);
        container.addEventListener('pointerleave', () => paused = false);

        // --- Popup & Click Logic ---
        const openPopup = t => { popupContent.textContent = t; popup.style.display = 'flex'; paused = true; };
        const closePopup = () => { popup.style.display = 'none'; paused = false; };
        popupClose.addEventListener('click', closePopup);
        popup.addEventListener('click', e => { if (e.target === popup) closePopup(); });

        container.addEventListener('click', e => {
            if (Math.abs(vel) > 0.1) return; // It was a drag, not a click
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            
            for (let i = active.length - 1; i >= 0; i--) {
                const msg = active[i];
                if (msg.sep) continue;
                if (clickX >= msg.left && clickX <= msg.right) {
                    // Check for custom click action first
                    if (typeof msg.opt.onClickAction === 'function') {
                        msg.opt.onClickAction(msg); // Execute the special command
                    } else {
                        openPopup(msg.extended()); // Default behavior: open popup
                    }
                    return; // Stop after handling the first clicked message
                }
            }
        });

        // --- Animation Loop ---
        const holdable = m => !m.sep && (m.opt.hold || m.tw > 450);
        
        // Simplified recycle function: always requeue
        const recycle = m => {
            addTickerMessage(m.src, m.opt);
        };

        const make = d => d instanceof Msg ? d : new Msg(d.text, d.options);

        function frame(ts) {
            const dt = (ts - last) / 1000; last = ts;
            if (!active.length && queue.length) active.push(make(queue.shift()));
            if (!isDrag && Math.abs(vel) > 0.0001) { shift(vel * dt * 1000); vel *= 0.92; }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let currentSpeed = BASE_SPD * (1 + Math.min(queue.length, 5) * 0.5);

            for (const m of active) {
                if (m.first) { m.x += currentSpeed * dt * 2; if (m.right >= -GAP) m.first = false; }
                else if (m.ease) { m.step(ts); }
                else if (!isDrag && !paused) { m.x += currentSpeed * dt; }
                
                ctx.font = `${m.opt.bold ? 'bold ' : ''}16px sans-serif`;
                ctx.fillStyle = m.opt.color;
                ctx.fillText(m.displayText, m.x + 18, canvas.height / 2);
            }

            for (let i = 1; i < active.length; i++) { const p = active[i - 1], c = active[i]; const maxR = p.left - GAP; if (c.right > maxR) c.x = maxR - 18; }
            if (active.length === 1 && !queue.length) { const m = active[0]; if (holdable(m) && !m.ease && !isDrag && !paused) { const c = (canvas.width + m.w) / 2; if (Math.abs(m.right - c) > 1) m.start(c, ts, 600); } }

            // Recycle messages that go off-screen
            if (active.length && active[0].left > canvas.width + MASK) {
                recycle(active.shift());
            }
            if (active.length && active[active.length - 1].right < -MASK) {
                recycle(active.pop());
            }
            
            // Add new messages from queue if there's space
            if (queue.length > 0) {
                const lastMsg = active[active.length - 1];
                if (!lastMsg || lastMsg.right < canvas.width - 50) {
                    if (lastMsg && !lastMsg.sep) {
                        active.push(make({ text: '|', options: { color: '#aaa' } }));
                    }
                    active.push(make(queue.shift()));
                }
            }
            
            requestAnimationFrame(frame);
        }

        function start() {
            if (running) return;
            running = true;
            last = performance.now();
            requestAnimationFrame(frame);
        }

        // --- Add initial messages ---
        addTickerMessage('专  住爪 专拽转!', { 
            color: '#4caf50', 
            details: ' 专住 11.1 注 注专转 拽专 转拽转.' 
        });
        addTickerMessage('爪 注 拽专 注拽  注 注 拽专 驻注', {
            color: '#03a9f4',
            bold: true,
            icon: ''
        });

        start();
    }
    
    // =========================================
    // 10. Idle Mode & Demo
    // =========================================
    function resetIdleTimer() { clearTimeout(idleTimeout); clearInterval(demoInterval); idleTimeout = setTimeout(startIdleMode, IDLE_TIME_MS); }
    function startIdleMode() {
        runDemoAction(); demoInterval = setInterval(runDemoAction, Math.random() * 4000 + 5000);
    }
    function runDemoAction() {
        setFollowedCube(null);
        const starCubes = keyCubes.filter(c => c.isStar);
        const actions = [
            () => { const randomStar = starCubes[Math.floor(Math.random() * starCubes.length)]; if(randomStar) navigateToStar(randomStar.id); },
            () => document.getElementById('earthquakeBtn').click(),
            () => document.getElementById('windBtn').click(),
            () => { const sel = document.getElementById('layout-select'); sel.selectedIndex = Math.floor(Math.random() * sel.options.length); sel.dispatchEvent(new Event('change')); },
            () => document.getElementById('toggleOrbitBtn').click(),
            () => document.getElementById('toggleWanderBtn').click(),
        ];
        if (expandedCube) { expandedCube.isExpanded = false; expandedCube = null; } 
        else { actions[Math.floor(Math.random() * actions.length)](); }
    }
    
    // =========================================
    // 11. Main Animation Loop & HUD
    // =========================================
    function updateHUD() {
        document.getElementById('objectCount').textContent=`拽: ${keyCubes.length}`;
        let gravText=document.querySelector(`#gravity-select option[value="${gravityMode}"]`).textContent;
        let status=`: ${gravText}`; if(orbitEnabled)status+=" | 住"; if(wanderEnabled)status+=" | 砖";
        document.getElementById('physicsStatus').textContent=status;
        document.getElementById('mouseCoords').textContent=`注专: (${Math.round(worldMouse.x)}, ${Math.round(worldMouse.y)})`;
        document.getElementById('fpsDisplay').textContent=`FPS: ${fps}`;
        document.getElementById('energyDisplay').textContent=`专: ${Math.round(totalKineticEnergy/1E3)}k`;
        document.getElementById('cameraPos').textContent = `爪: (${Math.round(view.x)}, ${Math.round(view.y)})`;
        const topLeft = screenToWorld(0, 0);
        document.getElementById('viewBounds').textContent = `转爪: [${Math.round(topLeft.x)}, ${Math.round(topLeft.y)}]`;
        updateZoomInfo();
    }

    function animate(timestamp) {
        requestAnimationFrame(animate);
        if(!lastTimestamp) lastTimestamp = timestamp;
        const dt = Math.min(0.033, (timestamp - lastTimestamp) / 1000);

        if(followedCube && !isPanning && !isMouseDown) {
            const cubesToFit = [followedCube, ...keyCubes.filter(c => c.parentId === followedCube.id)];
            const box = getBoundingBox(cubesToFit);

            if (box) {
                const padding = 1.35; 
                const boxWidth = box.maxX - box.minX;
                const boxHeight = box.maxY - box.minY;

                const targetScaleX = canvas.width / (boxWidth * padding);
                const targetScaleY = (canvas.height - headerHeight) / (boxHeight * padding);
                let targetScale = clamp(Math.min(targetScaleX, targetScaleY), MIN_SCALE, MAX_SCALE);
                
                const boxCenterX = (box.minX + box.maxX) / 2;
                const boxCenterY = (box.minY + box.maxY) / 2;
                
                const targetViewX = boxCenterX - (canvas.width / (2 * targetScale));
                const screenCenterY = headerHeight + (canvas.height - headerHeight) / 2;
                const targetViewY = boxCenterY - (screenCenterY / targetScale);

                const followFactor = 0.05; 
                view.x += (targetViewX - view.x) * followFactor;
                view.y += (targetViewY - view.y) * followFactor;
                view.scale += (targetScale - view.scale) * followFactor;
                
                view.targetX = view.x;
                view.targetY = view.y;
                view.targetScale = view.scale;
            }
        }

        frameCount++;
        if (timestamp - lastFpsUpdate > 1000) { fps = frameCount; frameCount = 0; lastFpsUpdate = timestamp; }
        if (timestamp - lastNavCheck > 300) { updateActiveNavFromView(); updateNavItemsState(); lastNavCheck = timestamp; }
        
        lastTimestamp = timestamp;

        springs.forEach(spring => spring.update());
        
        totalKineticEnergy = 0;
        keyCubes.forEach(cube => { 
            cube.handleInteractions(keyCubes);
            cube.update(dt); 
            const vSq = cube.vx * cube.vx + cube.vy * cube.vy;
            totalKineticEnergy += 0.5 * cube.mass * vSq;
        });

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(view.scale, view.scale);
        ctx.translate(-view.x, -view.y);

        springs.forEach(spring => spring.draw(ctx));
        keyCubes.sort((a,b) => a.expandProgress - b.expandProgress).forEach(cube => cube.draw(ctx));

        ctx.restore();
        updateGravityCenterMarker();
        updateHUD();
    }

    window.onload = init;
    </script>
</body>
</html>
