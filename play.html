<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orion Infinity Editor V7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700&display=swap');

        body {
            font-family: 'Heebo', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
        }

        /* --- Background Video Mixers --- */
        #video-stage {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0; background: #000; pointer-events: none;
        }

        .player-wrapper {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; transition: opacity 0.5s ease-in-out; 
        }
        
        .video-foreground { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        @media (min-aspect-ratio: 16/9) { .video-foreground iframe { width: 100%; height: 140%; top: -20%; } }
        @media (max-aspect-ratio: 16/9) { .video-foreground iframe { width: 140%; height: 100%; left: -20%; } }

        .player-wrapper iframe { width: 100%; height: 100%; pointer-events: none; }

        /* --- UI Overlay --- */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            display: flex; flex-direction: column;
        }

        #ui-layer.hidden-ui { opacity: 0; pointer-events: none; transform: scale(1.05); }

        /* --- Tabs & Content --- */
        .tab-bar {
            display: flex; background: #111; border-bottom: 1px solid #333;
            flex-shrink: 0;
        }
        .tab-btn {
            flex: 1; padding: 12px; text-align: center; color: #888; font-weight: bold;
            border-bottom: 2px solid transparent; transition: all 0.2s;
        }
        .tab-btn.active { color: #fff; border-bottom-color: #4ade80; background: #1a1a1a; }

        #tab-content-area { flex: 1; overflow-y: auto; padding: 15px; position: relative; }
        .view-section { display: none; }
        .view-section.active { display: block; }

        /* --- Sequence List Styling --- */
        .clip-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            margin-bottom: 8px;
            padding: 10px;
            display: flex; align-items: center; gap: 12px;
            transition: all 0.2s;
        }
        .clip-card.playing { border-color: #4ade80; background: #152515; }
        .clip-info { flex: 1; overflow: hidden; }
        .clip-title { font-weight: bold; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .clip-meta { font-size: 0.7rem; color: #888; display: flex; gap: 8px; margin-top: 2px; }
        .mini-timeline { height: 3px; background: #333; border-radius: 2px; margin-top: 6px; position: relative; width: 100%; }
        .mini-range { position: absolute; height: 100%; background: #4ade80; border-radius: 2px; }

        /* --- Source List Styling --- */
        .source-group { margin-bottom: 20px; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .source-header {
            background: #222; padding: 10px; display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #333;
        }
        .source-title { font-weight: bold; font-size: 0.9rem; color: #ddd; }
        .source-actions button { padding: 4px 8px; font-size: 0.7rem; border-radius: 4px; margin-left: 4px; }
        
        .source-clips { padding: 5px; background: #111; }
        .source-clip-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px; border-bottom: 1px solid #222; font-size: 0.8rem; color: #aaa;
        }
        .source-clip-item:last-child { border-bottom: none; }

        .btn-edit { background: #333; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; }

        /* --- EDITOR MODAL --- */
        #editor-modal {
            position: fixed; inset: 0; z-index: 50; background: #111;
            display: flex; flex-direction: column; transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #editor-modal.open { transform: translateY(0); }
        #editor-player-container { width: 100%; aspect-ratio: 16/9; background: #000; flex-shrink: 0; position: relative; }
        .editor-controls { padding: 20px; flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }

        /* Timeline */
        .timeline-wrapper { position: relative; height: 60px; display: flex; align-items: center; touch-action: none; margin: 0 10px; }
        .timeline-track { position: absolute; left: 0; right: 0; height: 12px; background: #222; border-radius: 6px; border: 1px solid #333; }
        .timeline-range { position: absolute; height: 12px; background: rgba(74, 222, 128, 0.3); border-radius: 2px; border-top: 1px solid #4ade80; border-bottom: 1px solid #4ade80; }
        .timeline-handle {
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 50px; z-index: 10; cursor: col-resize; display: flex; justify-content: center; align-items: center;
        }
        .timeline-handle::after { content: ''; display: block; width: 4px; height: 40px; border-radius: 2px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .handle-l { z-index: 12; } .handle-l::after { background: #4ade80; }
        .handle-r { z-index: 12; } .handle-r::after { background: #ef4444; }
        .handle-label { position: absolute; top: -25px; font-size: 10px; font-weight: bold; padding: 2px 4px; border-radius: 3px; pointer-events: none; white-space: nowrap; }
        .handle-l .handle-label { color: #4ade80; background: rgba(0,0,0,0.7); }
        .handle-r .handle-label { color: #ef4444; background: rgba(0,0,0,0.7); }
        .playhead { position: absolute; top: 10px; bottom: 10px; width: 2px; background: #fff; pointer-events: none; z-index: 5; opacity: 0.8; box-shadow: 0 0 4px white; }

        /* General UI */
        #settings-toggle { position: fixed; top: 20px; left: 20px; z-index: 30; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.2); width: 44px; height: 44px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; backdrop-filter: blur(4px); cursor: pointer; }
        #unmute-overlay { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 25; background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 30px; display: flex; align-items: center; gap: 10px; animation: fadeIn 1s ease-out; }
        #unmute-overlay.hidden { display: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

    </style>
</head>
<body>

    <!-- Background Mixers -->
    <div id="video-stage" onclick="app.unmuteAll()">
        <div id="player1-wrapper" class="player-wrapper video-foreground"><div id="player1"></div></div>
        <div id="player2-wrapper" class="player-wrapper video-foreground"><div id="player2"></div></div>
    </div>

    <!-- Toggle & Overlay -->
    <div id="settings-toggle" onclick="app.toggleUI()">âš™ï¸</div>
    <div id="unmute-overlay" onclick="app.unmuteAll()">
        <span>ğŸ”‡</span><span class="text-sm font-bold">×œ×—×¥ ×œ×”×¤×¢×œ×ª ×¡××•× ×“</span>
    </div>

    <!-- Main UI -->
    <div id="ui-layer" class="hidden-ui">
        <div class="p-3 bg-black/50 border-b border-white/10 flex justify-between items-center shrink-0">
            <h1 class="text-lg font-bold text-transparent bg-clip-text bg-gradient-to-l from-green-400 to-blue-500">Mixer V7</h1>
            <div class="flex gap-2">
                <button onclick="app.downloadJSON()" class="text-xs bg-gray-800 border border-gray-600 px-2 py-1 rounded">×©××•×¨</button>
                <button onclick="document.getElementById('file-input').click()" class="text-xs bg-gray-800 border border-gray-600 px-2 py-1 rounded">×˜×¢×Ÿ</button>
                <input type="file" id="file-input" accept=".json" style="display: none" onchange="app.uploadJSON(this)">
                <button onclick="app.toggleUI()" class="text-xl ml-2 text-gray-400">âœ•</button>
            </div>
        </div>

        <!-- TABS -->
        <div class="tab-bar">
            <div class="tab-btn active" onclick="app.switchTab('sequence')">×¡×™×§×•×•× ×¡ (Sequence)</div>
            <div class="tab-btn" onclick="app.switchTab('sources')">××§×•×¨×•×ª (Sources)</div>
        </div>

        <div id="tab-content-area">
            <!-- VIEW 1: SEQUENCE -->
            <div id="view-sequence" class="view-section active">
                <div id="playlist-container"></div>
                
                <div class="mt-8 text-center">
                    <button onclick="app.regeneratePlaylist()" class="bg-red-900/30 text-red-300 px-6 py-3 rounded-full border border-red-500/20 text-sm font-bold">ğŸ² ×¢×¨×‘×•×‘ ××—×“×© (Shuffle)</button>
                </div>
            </div>

            <!-- VIEW 2: SOURCES -->
            <div id="view-sources" class="view-section">
                <div class="mb-4 flex justify-end">
                    <button onclick="app.addVideoPrompt()" class="bg-green-600 text-white px-4 py-2 rounded text-sm font-bold">+ ×”×•×¡×£ ×œ×™× ×§ ×—×“×©</button>
                </div>
                <div id="sources-container"></div>
            </div>
        </div>
    </div>

    <!-- Editor Modal -->
    <div id="editor-modal">
        <div class="flex justify-between items-center p-4 bg-black border-b border-white/10">
            <h2 class="text-sm font-bold text-gray-300">×¢×¨×™×›×ª ××§×˜×¢</h2>
            <button onclick="editor.close()" class="text-white px-3 py-1 bg-gray-800 rounded">×¡×’×•×¨ ×•×©××•×¨</button>
        </div>

        <div id="editor-player-container">
            <div id="editor-player"></div>
        </div>

        <div class="editor-controls">
            <div class="flex justify-center gap-6 items-center">
                <button onclick="editor.togglePlay()" class="w-12 h-12 bg-white text-black rounded-full flex items-center justify-center text-xl font-bold">â–¶</button>
                <div class="text-center">
                    <div class="text-xs text-gray-500">×–××Ÿ</div>
                    <div id="editor-time-display" class="font-mono text-xl text-blue-400">00:00</div>
                </div>
            </div>

            <!-- Timeline -->
            <div class="px-2">
                <div class="flex justify-between text-xs text-gray-500 mb-6 px-1">
                    <span id="label-in">IN: 0.0s</span>
                    <span id="label-out">OUT: 5.0s</span>
                </div>
                
                <div class="timeline-wrapper" id="timeline-track-area">
                    <div class="timeline-track"></div>
                    <div class="timeline-range" id="timeline-fill"></div>
                    <div class="playhead" id="editor-playhead"></div>
                    <div class="timeline-handle handle-l" id="handle-in"><span class="handle-label">IN</span></div>
                    <div class="timeline-handle handle-r" id="handle-out"><span class="handle-label">OUT</span></div>
                </div>
                
                <div class="flex justify-between text-[10px] text-gray-600 mt-2 px-1">
                    <span>0:00</span>
                    <span id="total-duration-label">03:00</span>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3 mt-2">
                <button onclick="editor.duplicateClip()" class="bg-blue-900/40 text-blue-200 py-3 rounded border border-blue-500/30">ğŸ“„ ×©×›×¤×œ ×§×˜×¢</button>
                <button onclick="editor.deleteClip()" class="bg-red-900/40 text-red-200 py-3 rounded border border-red-500/30">ğŸ—‘ ××—×§ ×§×˜×¢</button>
            </div>
            
            <div class="h-10"></div>
        </div>
    </div>

    <script>
        // --- DATA ---
        const SOURCE_VIDEOS = [
            { id: 'LvdGbCkZAiY', title: '×× ×™ ×‘×œ ×œ×™', duration: 180 }, 
            { id: 'zUmTkhqFhgw', title: '×’×¨×™× ×˜×™ ×”×“×¡×˜××¨×˜', duration: 120 },
            { id: 'jCVjX_K0swc', title: 'ReLife ×”×“××™×™×”', duration: 60 },
            { id: '1bA6cTw1DJ4', title: '××•×˜×™ ×™×•× ×”×•×œ×“×ª', duration: 40 },
            { id: 'T9vEvAcai_I', title: '×’×¨×™×Ÿ ×¡×§×¨×™×Ÿ', duration: 30 },
            { id: 'WSL1iYAyj4I', title: '×’×‘×¨×™××œ ×¢×˜×™×¤×”', duration: 20 },
            { id: 'NT_4d8sSdls', title: '××¡×£ ××•×¨ ×¢×˜×™×¤×”', duration: 20 },
            { id: 'J1fY6H1cj3A', title: '×©×™×œ×•×˜', duration: 15 },
            { id: 'aydTo0aZRtA', title: '×¨×—×¤×Ÿ ×˜×¨××§×™× ×’', duration: 15 },
            { id: 'p02kAntlIyY', title: '× ×•×¢× ××™×›××œ ×§×œ×™×¤', duration: 180 },
            { id: '_rv2sMdyCpg', title: 'RedBull', duration: 60 }
        ];

        // --- APP LOGIC ---
        class LoopApp {
            constructor() {
                this.playlist = this.loadPlaylist();
                this.currentIndex = 0;
                this.isPlaying = false;
                this.activePlayer = 1;
                this.isMuted = true;
                this.monitorInterval = null;
                this.fadeInterval = null;
                this.nextLoaded = false;
                this.currentTab = 'sequence';
            }

            loadPlaylist() {
                const saved = localStorage.getItem('orionMixV7');
                if (saved) { try { return JSON.parse(saved); } catch(e) {} }
                return this.createAutoPlaylist();
            }

            createAutoPlaylist() {
                let list = [];
                SOURCE_VIDEOS.forEach(video => {
                    const step = 25; 
                    for (let t = 0; t < (video.duration || 30) - 5; t += step) {
                        list.push({
                            uuid: crypto.randomUUID(),
                            videoId: video.id,
                            title: video.title,
                            start: t,
                            duration: 5,
                            totalDuration: video.duration || 180
                        });
                    }
                });
                return list.sort(() => Math.random() - 0.5);
            }

            save() { localStorage.setItem('orionMixV7', JSON.stringify(this.playlist)); }

            toggleUI() {
                document.getElementById('ui-layer').classList.toggle('hidden-ui');
                this.renderUI();
            }

            switchTab(tab) {
                this.currentTab = tab;
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view-section').forEach(v => v.classList.remove('active'));
                
                // Index check: sequence=0, sources=1
                const idx = tab === 'sequence' ? 0 : 1;
                document.querySelectorAll('.tab-btn')[idx].classList.add('active');
                document.getElementById(`view-${tab}`).classList.add('active');
                
                this.renderUI();
            }

            renderUI() {
                if (this.currentTab === 'sequence') {
                    this.renderSequence();
                } else {
                    this.renderSources();
                }
            }

            // --- Render Sequence (Draggable List) ---
            renderSequence() {
                const container = document.getElementById('playlist-container');
                container.innerHTML = '';
                
                this.playlist.forEach((clip, idx) => {
                    const isActive = idx === this.currentIndex;
                    const total = clip.totalDuration || 100;
                    const leftP = (clip.start / total) * 100;
                    const widthP = (clip.duration / total) * 100;

                    const el = document.createElement('div');
                    el.className = `clip-card ${isActive ? 'playing' : ''}`;
                    el.draggable = true; // Drag logic simplified for brevity (can enable full sort if needed)
                    
                    // Allow Dragging
                    el.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', idx); });
                    el.addEventListener('dragover', e => { e.preventDefault(); });
                    el.addEventListener('drop', e => {
                        e.preventDefault();
                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                        const item = this.playlist.splice(fromIdx, 1)[0];
                        this.playlist.splice(idx, 0, item);
                        this.save();
                        this.renderSequence();
                    });

                    el.innerHTML = `
                        <div class="text-gray-500 text-xs font-mono w-6 text-center cursor-grab">â˜° ${idx+1}</div>
                        <div class="clip-info" onclick="editor.open(${idx})">
                            <div class="clip-title">${clip.title}</div>
                            <div class="mini-timeline"><div class="mini-range" style="left:${leftP}%; width:${widthP}%"></div></div>
                            <div class="clip-meta"><span>IN: ${clip.start.toFixed(1)}</span><span>DUR: ${clip.duration.toFixed(1)}s</span></div>
                        </div>
                        <button class="btn-edit" onclick="editor.open(${idx})">âœï¸</button>
                    `;
                    container.appendChild(el);
                });
            }

            // --- Render Sources (Grouped View) ---
            renderSources() {
                const container = document.getElementById('sources-container');
                container.innerHTML = '';
                
                // Group by Video ID
                const groups = {};
                this.playlist.forEach((clip, idx) => {
                    if(!groups[clip.videoId]) groups[clip.videoId] = { title: clip.title, clips: [] };
                    groups[clip.videoId].clips.push({ ...clip, originalIdx: idx });
                });

                Object.keys(groups).forEach(vidId => {
                    const g = groups[vidId];
                    
                    const groupEl = document.createElement('div');
                    groupEl.className = 'source-group';
                    
                    let clipsHtml = '';
                    g.clips.forEach(c => {
                        clipsHtml += `
                            <div class="source-clip-item">
                                <span>${c.start.toFixed(1)}s - ${(c.start+c.duration).toFixed(1)}s</span>
                                <div class="flex gap-2">
                                    <button class="text-blue-400" onclick="editor.open(${c.originalIdx})">×¢×¨×•×š</button>
                                </div>
                            </div>
                        `;
                    });

                    groupEl.innerHTML = `
                        <div class="source-header">
                            <div class="source-title">${g.title}</div>
                            <div class="source-actions">
                                <button class="bg-blue-900 text-blue-200" onclick="app.addClipToSource('${vidId}', '${g.title}')">+ ×§×˜×¢</button>
                                <button class="bg-red-900 text-red-200" onclick="app.deleteSource('${vidId}')">××—×§ ×”×›×œ</button>
                            </div>
                        </div>
                        <div class="source-clips">${clipsHtml}</div>
                    `;
                    container.appendChild(groupEl);
                });
            }

            // --- Actions ---
            addClipToSource(vidId, title) {
                // Find existing meta for this video if possible
                const existing = this.playlist.find(p => p.videoId === vidId);
                const totalDur = existing ? existing.totalDuration : 180;
                
                const newClip = {
                    uuid: crypto.randomUUID(),
                    videoId: vidId,
                    title: title,
                    start: 0,
                    duration: 5,
                    totalDuration: totalDur
                };
                this.playlist.push(newClip);
                this.save();
                this.renderUI();
            }

            deleteSource(vidId) {
                if(confirm('×œ××—×•×§ ××ª ×›×œ ×”×§×˜×¢×™× ×©×œ ×”×œ×™× ×§ ×”×–×”?')) {
                    this.playlist = this.playlist.filter(p => p.videoId !== vidId);
                    this.save();
                    this.renderUI();
                }
            }

            addVideoPrompt() {
                const url = prompt("Link:");
                if(url) {
                    let id = url.includes('v=') ? url.split('v=')[1].split('&')[0] : url.split('/').pop();
                    this.playlist.push({
                        uuid: crypto.randomUUID(), videoId: id, title: 'New Source', 
                        start: 0, duration: 5, totalDuration: 180 
                    });
                    this.save();
                    this.renderUI();
                }
            }
            
            regeneratePlaylist() {
                if(confirm('×œ××—×•×§ ×•×œ×™×¦×•×¨ ×¨×©×™××” ×—×“×©×”?')) {
                    this.playlist = this.createAutoPlaylist();
                    this.currentIndex = 0;
                    this.save();
                    this.renderUI();
                }
            }

            // --- Playback Engine ---
            startEngine() {
                this.isPlaying = true;
                this.playSequence(this.currentIndex);
                this.renderUI();
            }

            playSequence(index) {
                if (!this.isPlaying) return;
                if (index >= this.playlist.length) index = 0;
                this.currentIndex = index;

                if(!editor.isOpen) {
                    this.renderSequence(); // Highlight active
                    this._playInternal(index);
                }
            }

            _playInternal(index) {
                const clip = this.playlist[index];
                const currentP = this.activePlayer === 1 ? player1 : player2;
                const nextP = this.activePlayer === 1 ? player2 : player1;
                const currentWrapper = this.activePlayer === 1 ? document.getElementById('player1-wrapper') : document.getElementById('player2-wrapper');
                const nextWrapper = this.activePlayer === 1 ? document.getElementById('player2-wrapper') : document.getElementById('player1-wrapper');

                if (currentWrapper.style.opacity != '1') {
                    if(this.isMuted) currentP.mute(); else currentP.unMute();
                    currentP.loadVideoById({videoId: clip.videoId, startSeconds: clip.start});
                    currentP.playVideo();
                    currentWrapper.style.opacity = 1;
                    nextWrapper.style.opacity = 0;
                }

                this.nextLoaded = false;
                clearInterval(this.monitorInterval);
                
                this.monitorInterval = setInterval(() => {
                    if(editor.isOpen) { currentP.pauseVideo(); return; } 
                    
                    // Ensure playing
                    if(currentP.getPlayerState() === 2) currentP.playVideo();

                    const currTime = currentP.getCurrentTime();
                    if (!currTime) return;

                    const played = currTime - clip.start;
                    const remaining = clip.duration - played;

                    // Safety: if video accidentally ended or is invalid
                    if (remaining < -1) {
                         this.playSequence(this.currentIndex + 1);
                         return;
                    }

                    if (remaining <= 2.5 && !this.nextLoaded) {
                        this.nextLoaded = true;
                        let nextIdx = this.currentIndex + 1;
                        if (nextIdx >= this.playlist.length) nextIdx = 0;
                        const nextClip = this.playlist[nextIdx];
                        nextP.mute();
                        nextP.loadVideoById({ videoId: nextClip.videoId, startSeconds: nextClip.start });
                        nextP.playVideo();
                    }

                    if (remaining <= 1.5) {
                        clearInterval(this.monitorInterval);
                        this.doCrossfade(currentP, currentWrapper, nextP, nextWrapper);
                    }
                }, 200);
            }

            doCrossfade(pOut, wOut, pIn, wIn) {
                let step = 0;
                pIn.playVideo();
                clearInterval(this.fadeInterval);
                this.fadeInterval = setInterval(() => {
                    step++;
                    const progress = step / 10;
                    wOut.style.opacity = 1 - progress;
                    wIn.style.opacity = progress;
                    if (!this.isMuted) {
                        pOut.setVolume((1 - progress) * 100);
                        pIn.setVolume(progress * 100);
                        if (progress > 0.1) pIn.unMute();
                    }
                    if (step >= 10) {
                        clearInterval(this.fadeInterval);
                        wOut.style.opacity = 0; pOut.pauseVideo();
                        wIn.style.opacity = 1; if(!this.isMuted) pIn.setVolume(100);
                        this.activePlayer = this.activePlayer === 1 ? 2 : 1;
                        this.playSequence(this.currentIndex + 1);
                    }
                }, 150);
            }
            
            forceNext() {
                this.playSequence(this.currentIndex + 1);
            }

            unmuteAll() {
                this.isMuted = false;
                if(player1) player1.unMute();
                if(player2) player2.unMute();
                document.getElementById('unmute-overlay').classList.add('hidden');
            }
            
            downloadJSON() {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.playlist));
                const a = document.createElement('a'); a.href = dataStr; a.download = "mix.json"; a.click();
            }
            
            uploadJSON(input) {
                const f = input.files[0];
                if(!f) return;
                const r = new FileReader();
                r.onload = e => { this.playlist = JSON.parse(e.target.result); this.save(); this.renderUI(); };
                r.readAsText(f);
            }
        }

        // --- EDITOR LOGIC ---
        class Editor {
            constructor() {
                this.isOpen = false; this.clipIndex = null; this.clip = null;
                this.player = null; this.monitorTimer = null;
                this.dragging = null; this.trackWidth = 0;
            }

            init(ytPlayer) { this.player = ytPlayer; this.setupDragEvents(); }

            open(index) {
                this.isOpen = true; this.clipIndex = index; this.clip = app.playlist[index];
                if(player1 && player1.pauseVideo) player1.pauseVideo();
                if(player2 && player2.pauseVideo) player2.pauseVideo();
                document.getElementById('editor-modal').classList.add('open');
                this.player.loadVideoById({ videoId: this.clip.videoId, startSeconds: this.clip.start });
                this.updateUI(); this.startMonitor();
            }

            close() {
                this.isOpen = false; this.player.pauseVideo();
                clearInterval(this.monitorTimer);
                document.getElementById('editor-modal').classList.remove('open');
                app.save(); app.renderUI();
                app.playSequence(app.currentIndex); // Resume
            }

            updateUI() {
                const total = this.clip.totalDuration || 100;
                document.getElementById('total-duration-label').innerText = this.formatTime(total);
                this.drawTimeline();
                this.updateLabels();
            }
            
            drawTimeline() {
                const track = document.getElementById('timeline-track-area');
                this.trackWidth = track.clientWidth;
                const total = this.clip.totalDuration || 100;
                const startP = (this.clip.start / total) * 100;
                const endP = ((this.clip.start + this.clip.duration) / total) * 100;

                document.getElementById('handle-in').style.left = startP + '%';
                document.getElementById('handle-out').style.left = endP + '%';
                const fill = document.getElementById('timeline-fill');
                fill.style.left = startP + '%'; fill.style.width = (endP - startP) + '%';
            }
            
            updateLabels() {
                document.getElementById('label-in').innerText = `IN: ${this.clip.start.toFixed(1)}s`;
                document.getElementById('label-out').innerText = `OUT: ${(this.clip.start + this.clip.duration).toFixed(1)}s`;
            }

            togglePlay() {
                const state = this.player.getPlayerState();
                if (state === 1) this.player.pauseVideo(); else this.player.playVideo();
            }

            startMonitor() {
                clearInterval(this.monitorTimer);
                this.monitorTimer = setInterval(() => {
                    if(!this.isOpen) return;
                    const t = this.player.getCurrentTime();
                    if(!t) return;
                    const total = this.clip.totalDuration || 100;
                    const p = (t / total) * 100;
                    document.getElementById('editor-playhead').style.left = p + '%';
                    document.getElementById('editor-time-display').innerText = this.formatTime(t);
                    const end = this.clip.start + this.clip.duration;
                    if (t >= end) this.player.seekTo(this.clip.start);
                }, 100);
            }

            setupDragEvents() {
                const track = document.getElementById('timeline-track-area');
                const hIn = document.getElementById('handle-in');
                const hOut = document.getElementById('handle-out');

                const startDrag = (e, type) => { e.preventDefault(); this.dragging = type; this.trackWidth = track.clientWidth; };
                const eventOpts = { passive: false };

                hIn.addEventListener('touchstart', (e) => startDrag(e, 'in'), eventOpts);
                hIn.addEventListener('mousedown', (e) => startDrag(e, 'in'));
                hOut.addEventListener('touchstart', (e) => startDrag(e, 'out'), eventOpts);
                hOut.addEventListener('mousedown', (e) => startDrag(e, 'out'));

                const moveDrag = (e) => {
                    if (!this.dragging) return;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const rect = track.getBoundingClientRect();
                    let offsetX = clientX - rect.left;
                    if (offsetX < 0) offsetX = 0; if (offsetX > this.trackWidth) offsetX = this.trackWidth;
                    
                    const percent = offsetX / this.trackWidth;
                    const total = this.clip.totalDuration || 100;
                    const time = percent * total;

                    if (this.dragging === 'in') {
                        const currentEnd = this.clip.start + this.clip.duration;
                        if (time < currentEnd - 0.5) { this.clip.start = time; this.clip.duration = currentEnd - time; }
                    } else if (this.dragging === 'out') {
                        if (time > this.clip.start + 0.5) { this.clip.duration = time - this.clip.start; }
                    }
                    this.drawTimeline(); this.updateLabels(); this.player.seekTo(time, true); 
                };

                const endDrag = () => {
                    if(this.dragging) {
                        if(this.dragging === 'in') this.player.seekTo(this.clip.start);
                        else this.player.seekTo(this.clip.start + this.clip.duration - 1);
                        this.player.playVideo();
                    }
                    this.dragging = null;
                };

                window.addEventListener('touchmove', moveDrag, eventOpts);
                window.addEventListener('mousemove', moveDrag);
                window.addEventListener('touchend', endDrag);
                window.addEventListener('mouseup', endDrag);
            }

            duplicateClip() {
                const copy = JSON.parse(JSON.stringify(this.clip));
                copy.uuid = crypto.randomUUID(); copy.title += ' (copy)';
                copy.start += 5; if(copy.start > copy.totalDuration) copy.start = 0;
                app.playlist.splice(this.clipIndex + 1, 0, copy);
                app.save(); alert('×©×•×›×¤×œ!');
                // Close modal to see result
                this.close();
            }
            
            deleteClip() {
                if(confirm('×œ××—×•×§ ××ª ×”×§×˜×¢?')) { app.playlist.splice(this.clipIndex, 1); this.close(); }
            }

            formatTime(s) { const m = Math.floor(s / 60); const sec = Math.floor(s % 60); return `${m}:${sec < 10 ? '0'+sec : sec}`; }
        }

        // --- SETUP ---
        const app = new LoopApp();
        const editor = new Editor();

        let player1, player2, editorPlayer;
        
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        function onYouTubeIframeAPIReady() {
            const vars = { controls: 0, showinfo: 0, rel: 0, modestbranding: 1, iv_load_policy: 3, fs: 0, playsinline: 1, disablekb: 1, origin: window.location.origin };
            
            const onState = (e) => {
                // Auto-skip ended videos (fail-safe)
                if (e.data === YT.PlayerState.ENDED) {
                    // Only if app is supposed to be playing
                    if(app.isPlaying && !editor.isOpen) {
                        app.forceNext();
                    }
                }
            };

            player1 = new YT.Player('player1', { height:'100%', width:'100%', playerVars: vars, events: { 'onReady': onReady, 'onStateChange': onState } });
            player2 = new YT.Player('player2', { height:'100%', width:'100%', playerVars: vars, events: { 'onReady': onReady, 'onStateChange': onState } });
            editorPlayer = new YT.Player('editor-player', { height:'100%', width:'100%', playerVars: vars, events: { 'onReady': onEditorReady } });
        }

        let readyCount = 0;
        function onReady(e) {
            e.target.mute(); readyCount++;
            if(readyCount === 2) setTimeout(() => app.startEngine(), 500);
        }
        
        function onEditorReady(e) { editor.init(e.target); }

    </script>
</body>
</html>


