<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>אוריין אדלני - סימולציה אינטראקטיבית V4.1 (מתוקן)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* --- General & Reset Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body {
            background: linear-gradient(135deg, #1a1c20, #383b3e);
            font-family: 'Segoe UI', Arial, sans-serif;
            user-select: none;
            direction: rtl;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Top Controls Bar --- */
        header.top-nav-controls {
            position: fixed; top: 0; left: 0; right: 0;
            background-color: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(5px);
            color: #fff;
            z-index: 10000;
            height: auto;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            padding: 8px 15px;
            gap: 15px; /* Increased gap */
            border-bottom: 1px solid #444;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        header.top-nav-controls nav { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        header.top-nav-controls nav a {
            color: #fff; text-decoration: none; font-weight: bold; padding: 6px 12px;
            border-radius: 6px; font-size: 14px; transition: all 0.3s ease;
            cursor: pointer; border: 1px solid transparent;
        }
        header.top-nav-controls nav a:hover { background-color: rgba(255, 221, 87, 0.2); border-color: rgba(255, 221, 87, 0.4); }
        header.top-nav-controls nav a.active { background-color: #ffdd57; color: #111; border-color: #ffdd57; transform: translateY(-1px); box-shadow: 0 2px 5px rgba(255, 221, 87, 0.3); }

        .controls-separator { border-left: 1px solid #555; padding-left: 15px; margin-left: 15px; }

        .controls-group { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 8px; }
        .controls-group label { font-size: 13px; color: #ccc; }
        .controls-group button, .controls-group select {
            padding: 6px 12px; background: rgba(255,255,255,0.1); color: #eee;
            border: 1px solid #666; border-radius: 6px; cursor: pointer; font-size: 13px;
            transition: all 0.2s ease;
        }
        .controls-group button:hover:not(:disabled) { background: rgba(255, 255, 255, 0.25); border-color: #888; }
        .controls-group button:disabled { background: rgba(255,255,255,0.05); color: #777; cursor: not-allowed; border-color: #444; }
        .controls-group button.active { background: #ffdd57; color: #111; border-color: #ffdd57; transform: translateY(-1px); box-shadow: 0 1px 4px rgba(255, 221, 87, 0.2); }
        .controls-group select:focus { outline: none; border-color: #ffdd57;}
        .controls-group input[type="range"] { -webkit-appearance: none; appearance: none; width: 120px; height: 8px; background: #444; border-radius: 5px; outline: none; transition: opacity .2s; cursor: pointer;}
        .controls-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #ffdd57; border-radius: 50%; cursor: pointer; border: 2px solid #333; }
        .controls-group input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #ffdd57; border-radius: 50%; cursor: pointer; border: 2px solid #333;}
        .vortex-controls { display: flex; align-items: center; gap: 8px; transition: all 0.5s ease; max-width: 0; opacity: 0; overflow: hidden; }
        .vortex-controls.visible { max-width: 200px; opacity: 1; }

        /* --- Canvases & UI --- */
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #canvas { z-index: 1; background: transparent; }
        #hudContainer {
            position: fixed;
            top: 100px; /* Adjusted for smaller header */
            right: 15px;
            background: rgba(0,0,0,0.7);
            color: #ffc107;
            padding: 10px 15px;
            font-family: monospace;
            font-size: 13px;
            z-index: 1000;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: right;
            min-width: 200px;
        }
        #gravityCenterMarker {
            position: absolute; width: 24px; height: 24px;
            border: 3px solid rgba(255, 221, 87, 0.8);
            border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 5; pointer-events: none; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            background: radial-gradient(circle, rgba(255,221,87,0.4) 0%, rgba(255,221,87,0) 70%);
        }
        
        /* --- NEW TICKER --- */
        #ticker-container{position:fixed;bottom:0;left:0;width:100%;height:50px;background:#1c1e21;color:#fff;border-top:1px solid #3e4042;display:flex;align-items:center;overflow:hidden;user-select:none;touch-action:pan-y;cursor:pointer; z-index: 10001;}
        .ticker-label{background:#e4a80a;color:#1c1e21;padding:0 25px;font-weight:bold;font-size:18px;flex-shrink:0;height:100%;display:flex;align-items:center;z-index:2;}
        #ticker-canvas{flex-grow:1;height:100%;background:transparent;}
        /* Pop‑Up */
        .popup-overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:10002;}
        .popup-box{background:#fff;color:#333;max-width:600px;padding:30px;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,.3);font-size:18px;line-height:1.6;direction:rtl;position:relative;}
        .popup-close{position:absolute;top:10px;left:10px;font-size:24px;font-weight:bold;color:#999;cursor:pointer;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>

    <header class="top-nav-controls">
        <nav id="mainNav"></nav>
        <div class="controls-group controls-separator">
            <label for="layout-select">פריסה:</label>
            <select id="layout-select">
                <option value="circle">מעגל</option>
                <option value="grid-4x2">רשת 4x2</option>
                <option value="grid-2x4">רשת 2x4</option>
                <option value="horizontal">אופקי</option>
                <option value="vertical">אנכי</option>
            </select>
        </div>
        <div class="controls-group controls-separator">
            <button id="toggleWallsBtn">גבולות: ON</button>
            <button id="toggleMagnetBtn">מגנט: ON</button>
            <button id="toggleWanderBtn">שיטוט: OFF</button>
            <button id="toggleOrbitBtn">סיבוב: OFF</button>
            <button id="earthquakeBtn">רעידת אדמה</button>
            <button id="windBtn">משב רוח</button>
        </div>
        <div class="controls-group controls-separator">
            <label for="gravity-select">בקרת עולם:</label>
            <select id="gravity-select">
                <option value="none">ללא</option>
                <option value="down">כבידה מטה</option>
                <option value="center">כבידה למרכז</option>
                <option value="vortex">מערבולת</option>
            </select>
            <div id="vortex-controls" class="vortex-controls">
                <label for="vortex-slider">עוצמה:</label>
                <input type="range" id="vortex-slider" min="-100" max="100" value="0">
            </div>
        </div>
    </header>

    <canvas id="canvas"></canvas>
    <div id="hudContainer">
        <div id="zoomInfo">זום: 1.00x</div>
        <div id="objectCount"></div>
        <div id="physicsStatus"></div>
        <div id="mouseCoords"></div>
        <div id="fpsDisplay"></div>
        <div id="energyDisplay"></div>
    </div>
    <div id="gravityCenterMarker"></div>

    <!-- NEW TICKER HTML -->
    <div id="ticker-container">
        <div class="ticker-label">מבזקים</div>
        <canvas id="ticker-canvas"></canvas>
    </div>
    <div class="popup-overlay" id="popup">
        <div class="popup-box">
            <span class="popup-close" id="popup-close">×</span>
            <p id="popup-content"></p>
        </div>
    </div>


    <script>
    // =========================================
    // 1. Constants & Global Variables
    // =========================================
    // Core Elements & State
    let canvas, ctx, keyCubes = [], springs = [];
    let worldMouse = { x: 0, y: 0 }, screenMouse = { x: 0, y: 0 }, isMouseDown = false, draggedCube = null;
    let clickStartTime = 0, clickStartPos = {x:0, y:0};
    let lastTimestamp = 0, worldWidth, worldHeight, currentStarId = 'star-home', expandedCube = null;
    let headerHeight = 70;

    // Viewport
    let view = { x: 0, y: 0, scale: 1.0, targetScale: 1.0, targetX: 0, targetY: 0, isAnimating: false };
    const MIN_SCALE = 0.05, MAX_SCALE = 8.0, ZOOM_SENSITIVITY = 0.001, CLICK_THRESHOLD_DIST = 10, CLICK_THRESHOLD_TIME = 300;
    let viewportAnimation = null;
    let isPanning = false; let lastPanPos = { x: 0, y: 0 };

    // Physics & World Control
    const friction = 0.92; const baseSpringK = 0.02, starSpringK = 0.03, interStarSpringK = 0.005, MAX_VELOCITY = 150;
    let boundariesEnabled = true, magnetEnabled = true, wanderEnabled = false, orbitEnabled = false;
    let layoutMode = 'circle', gravityMode = 'none', vortexStrength = 0;
    let gravityCenter = { x: 0, y: 0 };

    // Interactive Forces & HUD Stats
    let earthquakeLevel = 0, windLevel = 0, lastEarthquakeClick = 0;
    let frameCount = 0, lastFpsUpdate = 0, fps = 0, totalKineticEnergy = 0;

    // Ticker & Idle Mode
    let feedToTicker; // Will be assigned by the ticker init function
    let idleTimeout, demoInterval; const IDLE_TIME_MS = 10000;
    const tickerMessageCooldowns = new Map();

    // Data with "Weight"
    const cubeData = [
        { id: "star-home", text: "ראשי", type: 'star', weight: 50 }, { id: "star-about", text: "אודות", type: 'star', weight: 45 }, { id: "star-skills", text: "מיומנויות", type: 'star', weight: 80 }, { id: "star-platforms", text: "פלטפורמות", type: 'star', weight: 70 }, { id: "star-live", text: "שירותי Live", type: 'star', weight: 75 }, { id: "star-content", text: "סוגי תוכן", type: 'star', weight: 60 }, { id: "star-contact", text: "צור קשר", type: 'star', weight: 30 },
        { id: "welcome", text: "ברוכים הבאים", type: 'card', parentId: 'star-home', weight: 10 }, { id: "explore", text: "חקור את האתר", type: 'card', parentId: 'star-home', weight: 12 },
        { id: "orian", text: "מי אני?", type: 'card', parentId: 'star-about', weight: 20 }, { id: "psycho", text: "PsychoFlash", type: 'card', parentId: 'star-about', weight: 18 }, { id: "volunteer", text: "התנדבות", type: 'card', parentId: 'star-about', weight: 15 },
        { id: "ps", text: "Photoshop", type: 'skill', parentId: 'star-skills', weight: 10 }, { id: "ae", text: "After Effects", type: 'skill', parentId: 'star-skills', weight: 10 }, { id: "pr", text: "Premiere Pro", type: 'skill', parentId: 'star-skills', weight: 8 }, { id: "animate", text: "Animate", type: 'skill', parentId: 'star-skills', weight: 7 }, { id: "webdev", text: "Web Dev", type: 'skill', parentId: 'star-skills', weight: 15 },
        { id: "vmix", text: "Vmix Coding", type: 'live', parentId: 'star-live', weight: 22 }, { id: "techConsult", text: "Tech Consulting", type: 'live', parentId: 'star-live', weight: 19 },
        { id: "email", text: "אימייל", type: 'contact', parentId: 'star-contact', weight: 5 }, { id: "phone", text: "טלפון", type: 'contact', parentId: 'star-contact', weight: 5 }, { id: "facebook", text: "פייסבוק", type: 'contact', parentId: 'star-contact', weight: 5 },
    ];

    // =========================================
    // 2. Utility Functions
    // =========================================
    function clamp(v, minv, maxv) { return Math.max(minv, Math.min(maxv, v)); }
    function screenToWorld(screenX, screenY) { return { x: view.x + screenX / view.scale, y: view.y + screenY / view.scale }; }
    function worldToScreen(worldX, worldY) { return { x: (worldX - view.x) * view.scale, y: (worldY - view.y) * view.scale }; }

    // =========================================
    // 3. Core Classes (KeyCube, Spring)
    // =========================================
    class KeyCube {
        constructor(id, text, type, parentId = null, weight = 10) {
            this.id = id; this.text = text; this.type = type; this.isStar = (type === 'star'); this.weight = weight;
            this.parentId = parentId;
            this.x = Math.random() * worldWidth; this.y = Math.random() * worldHeight;
            this.vx = 0; this.vy = 0;
            this.gridX = this.x; this.gridY = this.y;
            this.baseWidth = this.isStar ? 250 : 150; this.baseHeight = this.isStar ? 150 : 100;
            this.width = this.baseWidth; this.height = this.baseHeight;
            this.color = this.getColorByType(type); this.textColor = "#ffffff";
            this.dragging = false;
            this.mass = this.isStar ? this.weight / 1.5 : this.weight / 5;
            this.isExpanded = false; this.expandProgress = 0;
            this.lastRepulsionForce = {x:0, y:0};
            this.closeButtonRect = null;
        }

        getColorByType(type) {
            switch (type) { case 'star': return 'rgba(255, 220, 80, 0.9)'; case 'skill': return 'rgba(255, 152, 0, 0.8)'; case 'live': return 'rgba(233, 30, 99, 0.8)'; case 'contact': return 'rgba(60, 80, 200, 0.8)'; default: return 'rgba(120, 120, 120, 0.8)'; }
        }
        applyForce(fx, fy) { this.vx += fx / this.mass; this.vy += fy / this.mass; }
        update(dt) {
            const expandSpeed = 0.1;
            if (this.isExpanded) { this.expandProgress = Math.min(1, this.expandProgress + expandSpeed); }
            else { this.expandProgress = Math.max(0, this.expandProgress - expandSpeed); }

            const targetWidth = this.isExpanded ? (canvas.width / view.scale * 0.9) : this.baseWidth;
            const targetHeight = this.isExpanded ? (canvas.height / view.scale * 0.8) : this.baseHeight;
            this.width += (targetWidth - this.width) * expandSpeed;
            this.height += (targetHeight - this.height) * expandSpeed;

            if (this.isExpanded) {
                const targetScreenY = headerHeight + (canvas.height - headerHeight) / 2;
                const targetPos = screenToWorld(canvas.width / 2, targetScreenY);
                this.x += (targetPos.x - this.x) * 0.2; this.y += (targetPos.y - this.y) * 0.2;
                this.vx *= 0.1; this.vy *= 0.1;
                return;
            }

            if(!this.dragging) {
                if (magnetEnabled) {
                    const dx = this.gridX - this.x; const dy = this.gridY - this.y;
                    const effStr = this.isStar ? 0.05 * 1.5 : 0.05; this.applyForce(dx * effStr, dy * effStr);
                }
                if (wanderEnabled) {
                    const wf = this.isStar ? 1.2 : 1.0;
                    const wanderImpulse = 0.6 * wf;
                    this.applyForce((Math.random()-0.5) * wanderImpulse, (Math.random()-0.5) * wanderImpulse);
                }

                const isOrbiting = orbitEnabled && !this.isStar && this.parentId;
                if (isOrbiting) {
                    const parent = keyCubes.find(c => c.id === this.parentId);
                    if (parent && !parent.isExpanded) {
                        const odx = parent.x - this.x; const ody = parent.y - this.y;
                        const odist = Math.hypot(odx, ody);
                        if(odist > 1) {
                            const strength = 0.5 + (vortexStrength / 100) * 0.6;
                            this.applyForce(ody / odist * strength, -odx / odist * strength);
                        }
                    }
                } else {
                    switch(gravityMode) {
                        case 'down': this.applyForce(0, 1.8 * this.mass); break;
                        case 'center':
                            const dx = gravityCenter.x - this.x; const dy = gravityCenter.y - this.y;
                            this.applyForce(dx * 0.01, dy * 0.01);
                            break;
                        case 'vortex':
                            const vdx = gravityCenter.x - this.x; const vdy = gravityCenter.y - this.y;
                            const vdist = Math.hypot(vdx, vdy);
                            if (vdist > 10) {
                                const strength = (vortexStrength / 100) * 350;
                                this.applyForce(vdy / vdist * strength, -vdx / vdist * strength);
                                this.applyForce(vdx * 0.003, vdy * 0.003);
                            }
                            break;
                    }
                }
            }

            if(this.dragging) {
                this.x = worldMouse.x; this.y = worldMouse.y;
                this.vx = 0; this.vy = 0;
            } else {
                this.vx = clamp(this.vx * friction, -MAX_VELOCITY, MAX_VELOCITY);
                this.vy = clamp(this.vy * friction, -MAX_VELOCITY, MAX_VELOCITY);
                this.x += this.vx * dt * 60; this.y += this.vy * dt * 60;
            }

            if (boundariesEnabled) {
                const r = 0.5; const hw = this.width/2; const hh = this.height/2;
                if (this.x < hw) { this.x = hw; this.vx *= -r; }
                else if (this.x > worldWidth - hw) { this.x = worldWidth - hw; this.vx *= -r; }
                if (this.y < hh) { this.y = hh; this.vy *= -r; }
                else if (this.y > worldHeight - hh) { this.y = worldHeight - hh; this.vy *= -r; }
            }
        }
        handleInteractions(others) {
            if (this.dragging || this.isExpanded) return;
            this.lastRepulsionForce = {x: 0, y: 0};
            others.forEach(other => {
                if (other === this || other.isExpanded) return;
                const dx = other.x - this.x; const dy = other.y - this.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < 1) distSq=1;
                const minDist = (this.width + other.width) / 2 + 20;
                if (distSq < minDist * minDist) {
                    const dist = Math.sqrt(distSq);
                    const overlap = minDist - dist;
                    const force = overlap * 0.6;
                    const totalMass = this.mass + other.mass;
                    const forceX = -dx/dist*force*(other.mass/totalMass);
                    const forceY = -dy/dist*force*(other.mass/totalMass);
                    this.applyForce(forceX, forceY);
                    this.lastRepulsionForce.x += forceX;
                    this.lastRepulsionForce.y += forceY;
                }
            });
        }
        draw(ctx) {
            const halfW = this.width / 2, halfH = this.height / 2;
            const left = this.x - halfW, top = this.y - halfH;
            const alpha = ctx.globalAlpha;

            if (expandedCube && expandedCube !== this) {
                ctx.globalAlpha *= clamp((1 - expandedCube.expandProgress) * 0.5, 0, 1);
                if (ctx.globalAlpha < 0.01) { ctx.globalAlpha = alpha; return; }
            }

            if (this.expandProgress > 0) {
                ctx.save();
                ctx.globalAlpha = this.expandProgress;
                const expandedColor = this.getColorByType(this.type).replace(/[\d\.]+\)$/g, '0.97)');
                ctx.fillStyle = expandedColor;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 30 * this.expandProgress;
                ctx.beginPath();
                ctx.roundRect(left, top, this.width, this.height, [20]);
                ctx.fill();
                ctx.shadowColor = 'transparent';

                const padding = 30 * this.expandProgress;
                ctx.fillStyle = this.textColor;
                ctx.textAlign = "right";
                ctx.textBaseline = "top";
                let titleFontSize = clamp(this.height * 0.05, 20, 40) * this.expandProgress;
                ctx.font = `bold ${titleFontSize}px Arial`;
                ctx.fillText(this.text, left + this.width - padding, top + padding);

                if (this.expandProgress > 0.6) {
                    const contentWidth = this.width - padding * 2;
                    const contentHeight = this.height - padding * 2 - 50 - titleFontSize;
                    const contentX = left + padding;
                    const contentY = top + padding + titleFontSize + 20;
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(contentX, contentY, contentWidth, contentHeight);
                    ctx.clip();
                    let bodyFontSize = clamp(this.height * 0.025, 12, 22);
                    ctx.font = `${bodyFontSize}px Arial`;
                    const bodyContent = getCubeContent(this.id);
                    const lines = bodyContent.split('\n');
                    let currentY = contentY;
                    for (const line of lines) {
                        ctx.fillText(line, contentX + contentWidth - 10, currentY);
                        currentY += bodyFontSize * 1.5;
                        if (currentY > contentY + contentHeight) break;
                    }
                    ctx.restore();
                }

                const closeBtnSize = 35 * this.expandProgress;
                this.closeButtonRect = { x: left + padding - (closeBtnSize/2), y: top + padding, w: closeBtnSize, h: closeBtnSize };
                ctx.fillStyle = 'rgba(233, 30, 99, 0.9)';
                ctx.beginPath();
                ctx.roundRect(this.closeButtonRect.x, this.closeButtonRect.y, closeBtnSize, closeBtnSize, [8]);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                const margin = 10 * this.expandProgress;
                ctx.moveTo(this.closeButtonRect.x + margin, this.closeButtonRect.y + margin);
                ctx.lineTo(this.closeButtonRect.x + closeBtnSize - margin, this.closeButtonRect.y + closeBtnSize - margin);
                ctx.moveTo(this.closeButtonRect.x + closeBtnSize - margin, this.closeButtonRect.y + margin);
                ctx.lineTo(this.closeButtonRect.x + margin, this.closeButtonRect.y + closeBtnSize - margin);
                ctx.stroke();

                ctx.restore();
                if (this.expandProgress >= 1.0) { ctx.globalAlpha = alpha; return; }
            }

            ctx.save();
            ctx.globalAlpha = ctx.globalAlpha * (1 - this.expandProgress);
            if (ctx.globalAlpha > 0.01) {
                const br = this.isStar ? 15 : 10;
                ctx.fillStyle = this.color;
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 10;
                ctx.beginPath(); ctx.roundRect(left, top, this.width, this.height, [br]); ctx.fill();
                ctx.shadowColor = 'transparent';

                ctx.fillStyle=this.textColor;
                ctx.textAlign="center"; ctx.textBaseline="middle";
                let fs = clamp(this.width/(this.isStar?4:5), 10, this.isStar?40:24);
                ctx.font=`bold ${fs}px Arial`;
                ctx.fillText(this.text,this.x,this.y);

                if (this.dragging){
                    ctx.strokeStyle="rgba(255,255,0,0.9)"; ctx.lineWidth=4;
                    ctx.beginPath(); ctx.roundRect(left,top,this.width,this.height,[br]); ctx.stroke();
                }
            }
            ctx.restore();
            ctx.globalAlpha = alpha;
        }

        isPointInside(px, py) { return px >= this.x - this.width/2 && px <= this.x + this.width/2 && py >= this.y - this.height/2 && py <= this.y + this.height/2; }

        isCloseButtonHit(worldX, worldY) {
            if (!this.isExpanded || !this.closeButtonRect) return false;
            const rect = this.closeButtonRect;
            return worldX >= rect.x && worldX <= rect.x + rect.w &&
                   worldY >= rect.y && worldY <= rect.y + rect.h;
        }
    }

    class Spring {
        constructor(cA, cB, rL, s){this.cubeA=cA;this.cubeB=cB;this.restLength=rL;this.stiffness=s;this.damping=0.15;}
        update(){
            if(!this.cubeA || !this.cubeB || this.cubeA.isExpanded || this.cubeB.isExpanded) return;
            const dx=this.cubeB.x-this.cubeA.x;const dy=this.cubeB.y-this.cubeA.y;let d=Math.hypot(dx,dy);if(d<1)d=1;
            const disp=d-this.restLength;const sFm=disp*this.stiffness;
            const rVx=this.cubeB.vx-this.cubeA.vx;const rVy=this.cubeB.vy-this.cubeA.vy;
            const vAS=(rVx*dx+rVy*dy)/d;const dFm=vAS*this.damping;
            const tFm=sFm+dFm;
            const fX=(dx/d)*tFm;const fY=(dy/d)*tFm;
            if(!this.cubeA.dragging)this.cubeA.applyForce(fX,fY);
            if(!this.cubeB.dragging)this.cubeB.applyForce(-fX,-fY);
        }
        draw(ctx){
            if(!this.cubeA || !this.cubeB || this.cubeA.isExpanded || this.cubeB.isExpanded || expandedCube) return;
            const alpha = Math.max(0, 1 - this.cubeA.expandProgress) * Math.max(0, 1 - this.cubeB.expandProgress);
            if (alpha < 0.1) return;
            ctx.beginPath(); ctx.moveTo(this.cubeA.x, this.cubeA.y); ctx.lineTo(this.cubeB.x, this.cubeB.y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.12 * alpha})`; ctx.lineWidth = 1.5; ctx.stroke();
        }
    }

    // =========================================
    // 4. Setup & Initialization Functions
    // =========================================
    function init() {
        canvas = document.getElementById('canvas'); ctx = canvas.getContext('2d');
        headerHeight = document.querySelector('header.top-nav-controls')?.offsetHeight || 70;
        setupWorld();
        gravityCenter = { x: worldWidth / 2, y: worldHeight / 2};
        keyCubes = cubeData.map(item => new KeyCube(item.id, item.text, item.type, item.parentId, item.weight));
        populateNav();
        resetPhysics(true);
        initNewTicker(); // Initialize the new ticker
        setupEventListeners();
        const homeStar = keyCubes.find(c => c.id === 'star-home');
        if (homeStar) { centerViewOn(homeStar.x, homeStar.y, 0.8, true); setActiveNav('star-home'); }
        resetIdleTimer();
        lastTimestamp = performance.now();
        requestAnimationFrame(animate);
    }

    function setupWorld() { worldWidth = 5000; worldHeight = 5000; resizeCanvas(); }

    function populateNav() {
        const navElement = document.getElementById('mainNav');
        navElement.innerHTML = '';
        keyCubes.filter(cube => cube.isStar).forEach(starCube => {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = starCube.text;
            link.setAttribute('data-target', starCube.id);
            link.onclick = (e) => { e.preventDefault(); navigateToStar(starCube.id); };
            navElement.appendChild(link);
        });
    }

    function setActiveNav(activeStarId) {
        document.querySelectorAll('#mainNav a').forEach(link => {
            link.classList.toggle('active', link.getAttribute('data-target') === activeStarId);
        });
        currentStarId = activeStarId;
    }

    function resizeCanvas() { if (!canvas) return; canvas.width = window.innerWidth; canvas.height = window.innerHeight; headerHeight = document.querySelector('header.top-nav-controls')?.offsetHeight || 70;}

    function assignGridPositions() {
        switch(layoutMode) {
            case 'circle': assignGridPositionsCircle(); break;
            case 'grid-4x2': assignGridPositionsGrid(4, 2); break;
            case 'grid-2x4': assignGridPositionsGrid(2, 4); break;
            case 'horizontal': assignGridPositionsLine(true); break;
            case 'vertical': assignGridPositionsLine(false); break;
        }
    }

    function assignGridPositionsCircle() {
        const stars = keyCubes.filter(c => c.isStar);
        const starLayoutRadius = Math.min(worldWidth, worldHeight) * 0.35;
        const angleStepStar = (2 * Math.PI) / stars.length;
        stars.forEach((star, index) => {
            const angle = index * angleStepStar - Math.PI / 2;
            star.gridX = worldWidth / 2 + Math.cos(angle) * starLayoutRadius;
            star.gridY = worldHeight / 2 + Math.sin(angle) * starLayoutRadius;
            setChildCardPositions(star);
        });
    }

    function assignGridPositionsGrid(cols, rows) {
        const stars = keyCubes.filter(c => c.isStar);
        const padding = 1000;
        const cellWidth = (worldWidth - padding) / cols;
        const cellHeight = (worldHeight - padding) / rows;
        stars.forEach((star, i) => {
            const col = i % cols;
            const row = Math.floor(i / cols);
            star.gridX = (col + 0.5) * cellWidth + padding / 2;
            star.gridY = (row + 0.5) * cellHeight + padding / 2;
            setChildCardPositions(star);
        });
    }

    function assignGridPositionsLine(isHorizontal) {
        const stars = keyCubes.filter(c => c.isStar);
        const padding = 1000;
        const count = stars.length || 1;
        const step = isHorizontal ? (worldWidth - padding) / count : (worldHeight - padding) / count;
        stars.forEach((star, i) => {
            star.gridX = isHorizontal ? (i + 0.5) * step + padding/2 : worldWidth / 2;
            star.gridY = isHorizontal ? worldHeight / 2 : (i + 0.5) * step + padding/2;
            setChildCardPositions(star);
        });
    }

    function setChildCardPositions(star) {
        const childCards = keyCubes.filter(c => c.parentId === star.id);
        if (childCards.length === 0) return;
        const angleStepCard = (2 * Math.PI) / childCards.length;
        childCards.forEach((card, index) => {
            const angle = index * angleStepCard;
            const baseDist = 150 + (star.weight * 1.5) + (card.weight * 4);
            const r = baseDist * (0.9 + Math.random() * 0.2);
            card.gridX = star.gridX + Math.cos(angle) * r;
            card.gridY = star.gridY + Math.sin(angle) * r;
        });
    }

    function buildSprings() {
        springs = [];
        const stars = keyCubes.filter(c => c.isStar);
        keyCubes.forEach(card => {
            if (!card.isStar && card.parentId) {
                const parentStar = keyCubes.find(c => c.id === card.parentId);
                if (parentStar) {
                    const baseDist = 150 + (parentStar.weight * 1.5) + (card.weight * 8);
                    const restLength = baseDist * (0.9 + Math.random() * 0.2);
                    springs.push(new Spring(card, parentStar, restLength, starSpringK));
                }
            }
        });
        for (let i = 0; i < stars.length; i++) {
            for (let j = i + 1; j < stars.length; j++) {
                const starA = stars[i]; const starB = stars[j];
                const restLength = Math.hypot(starB.gridX - starA.gridX, starB.gridY - starA.gridY);
                springs.push(new Spring(starA, starB, restLength, interStarSpringK));
            }
        }
    }


    // =========================================
    // 5. Viewport Control & Navigation
    // =========================================
    function centerViewOn(worldX, worldY, targetScale = view.targetScale, immediate = false) {
        view.targetScale = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        view.targetX = worldX - (canvas.width / (2 * view.targetScale));
        view.targetY = worldY - (canvas.height / (2 * view.targetScale));
        if (immediate) {
            view.x = view.targetX; view.y = view.targetY; view.scale = view.targetScale;
            view.isAnimating = false; if (viewportAnimation) viewportAnimation.kill();
        } else { animateViewport(); }
        updateZoomInfo();
    }

    function navigateToStar(starId) {
        if(expandedCube) { expandedCube.isExpanded = false; expandedCube = null; }
        const starCube = keyCubes.find(c => c.id === starId);
        if (!starCube) return;
        const targetScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, canvas.width / (starCube.width * 3.5)));
        setActiveNav(starId);
        centerViewOn(starCube.x, starCube.y, targetScale);
        feedToTicker({
            type: 'navigation',
            text: `ניווט אל: ${starCube.text}`,
            options: { color: '#87CEEB', lifetime: 'single' }
        });
    }

    function animateViewport() {
        if (view.isAnimating && viewportAnimation) return;
        view.isAnimating = true; if (viewportAnimation) viewportAnimation.kill();
        viewportAnimation = gsap.to(view, {
            duration: 1.2, x: view.targetX, y: view.targetY, scale: view.targetScale,
            ease: "power3.inOut",
            onUpdate: updateZoomInfo,
            onComplete: () => { view.isAnimating = false; viewportAnimation = null; },
            onInterrupt: () => { view.isAnimating = false; viewportAnimation = null; view.targetX = view.x; view.targetY = view.y; view.targetScale = view.scale; }
        });
    }

    function updateZoomInfo() {
        const el = document.getElementById('zoomInfo');
        if(el) el.textContent = `זום: ${view.scale.toFixed(2)}x`;
    }


    // =========================================
    // 6. Event Listeners & Interaction
    // =========================================
    function setupEventListeners() {
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        window.addEventListener('resize', setupWorld);

        document.getElementById('layout-select').addEventListener('change', (e) => {
            layoutMode = e.target.value;
            feedToTicker({ type: 'layout_change', text: `פריסה שונתה ל: ${e.target.options[e.target.selectedIndex].text}`, options:{color:'#ffdd57', lifetime: 5000}});
            assignGridPositions();
            buildSprings();
        });

        document.getElementById('toggleWallsBtn')?.addEventListener('click', (e) => { boundariesEnabled = !boundariesEnabled; e.target.textContent = `גבולות: ${boundariesEnabled ? 'ON' : 'OFF'}`; e.target.classList.toggle('active', boundariesEnabled) });
        document.getElementById('toggleMagnetBtn')?.addEventListener('click', (e) => { magnetEnabled = !magnetEnabled; e.target.textContent = `מגנט: ${magnetEnabled ? 'ON' : 'OFF'}`; e.target.classList.toggle('active', magnetEnabled)});
        document.getElementById('toggleWanderBtn')?.addEventListener('click', (e) => { wanderEnabled = !wanderEnabled; e.target.textContent = `שיטוט: ${wanderEnabled ? 'ON' : 'OFF'}`; e.target.classList.toggle('active', wanderEnabled) });
        document.getElementById('toggleOrbitBtn')?.addEventListener('click', (e) => { orbitEnabled = !orbitEnabled; e.target.textContent = `סיבוב: ${orbitEnabled ? 'ON' : 'OFF'}`; e.target.classList.toggle('active', orbitEnabled) });

        document.getElementById('earthquakeBtn')?.addEventListener('click', () => {
            const now = performance.now();
            if (now - lastEarthquakeClick < 1500 && earthquakeLevel > 0) {
                 feedToTicker({type: 'user_rage', text: `נראה שהמשתמש כועס... מגביר רעידת אדמה!`, options:{color:'#e91e63', bold:true, hold:true, lifetime: 'single'}});
            }
            lastEarthquakeClick = now;

            earthquakeLevel++;
            feedToTicker({type: 'earthquake', text: `הופעלה רעידת אדמה בעוצמה ${earthquakeLevel}!`, options:{color:'#ff9800', bold:true, lifetime: 6000}});
            const strength = (180 + (Math.random() - 0.5) * 80) * earthquakeLevel;
            keyCubes.forEach(cube => {
                if (!cube.dragging && !cube.isExpanded) {
                    const angle = Math.random() * Math.PI * 2;
                    cube.applyForce(Math.cos(angle) * strength, Math.sin(angle) * strength + (cube.mass * -45));
                }
            });
            if(earthquakeLevel > 1) {
                for(let i = 1; i < earthquakeLevel; i++) {
                    setTimeout(() => {
                        feedToTicker({type: 'aftershock', text: `רעד משנה מורגש...`, options:{color:'#ffc107', lifetime: 2000}});
                        keyCubes.forEach(c => c.applyForce((Math.random()-0.5)*strength*0.4, (Math.random()-0.5)*strength*0.4));
                    }, i * (500 + Math.random() * 400) );
                }
            }
            setTimeout(() => earthquakeLevel = Math.max(0, earthquakeLevel - 1), 6000);
        });

        document.getElementById('windBtn')?.addEventListener('click', () => {
            windLevel++;
            const duration = 2000 + windLevel * 800;
            feedToTicker({type: 'wind', text: `משב רוח אדיר בעוצמה ${windLevel}!`, options:{color:'#03a9f4', bold: true, lifetime: duration}});
            const baseStrength = 12.0 * windLevel * (0.8 + Math.random() * 0.4);
            const angle = Math.random() * Math.PI * 2;
            const windForce = { x: Math.cos(angle) * baseStrength, y: Math.sin(angle) * baseStrength };
            let windInterval = setInterval(() => {
                keyCubes.forEach(cube => {
                    if (!cube.dragging && !cube.isExpanded) cube.applyForce(windForce.x * (Math.random() * 0.5 + 0.5), windForce.y * (Math.random() * 0.5 + 0.5));
                });
            }, 100);
            setTimeout(() => {
                clearInterval(windInterval);
                feedToTicker({type: 'wind_end', text: `הרוח נרגעה.`, options:{color:'#b3e5fc', lifetime: 3000}});
                windLevel = Math.max(0, windLevel - 1);
            }, duration);
        });

        document.getElementById('gravity-select').addEventListener('change', (e) => {
            gravityMode = e.target.value;
            document.getElementById('vortex-controls').classList.toggle('visible', gravityMode === 'vortex');
            updateGravityCenterMarker();
        });
        document.getElementById('vortex-slider').addEventListener('input', (e) => { vortexStrength = parseInt(e.target.value, 10); });

        ['mousedown', 'mousemove', 'wheel', 'keydown', 'touchstart'].forEach(evt => document.addEventListener(evt, resetIdleTimer, false));
    }

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    function onPointerDown(e) {
        isMouseDown = true;
        const pos = getEventPos(e);
        screenMouse = pos;
        worldMouse = screenToWorld(pos.x, pos.y);
        clickStartTime = performance.now();
        clickStartPos = { ...worldMouse };
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); view.isAnimating = false; }
        draggedCube = null; isPanning = false;

        if (expandedCube) {
            if (expandedCube.isCloseButtonHit(worldMouse.x, worldMouse.y)) {
                expandedCube.isExpanded = false;
                expandedCube = null;
            }
            isMouseDown = false;
            return;
        }

        for (let i = keyCubes.length - 1; i >= 0; i--) {
            const cube = keyCubes[i];
            if (cube.isPointInside(worldMouse.x, worldMouse.y)) {
                draggedCube = cube;
                cube.dragging = true;
                keyCubes.splice(i, 1);
                keyCubes.push(draggedCube);
                feedToTicker({
                    type: 'drag_start',
                    text: () => draggedCube ? `גורר את: ${draggedCube.text}` : '',
                    options: { color: '#ffee58', lifetime: 'event', eventId: 'drag' }
                });
                break;
            }
        }
        if (!draggedCube && !expandedCube) { isPanning = true; lastPanPos = { ...screenMouse }; }
    }

    function onPointerMove(e) {
        if (!isMouseDown || expandedCube) return;
        const pos = getEventPos(e);
        screenMouse = pos;
        worldMouse = screenToWorld(pos.x, pos.y);
        if (isPanning) {
            const dx = pos.x - lastPanPos.x; const dy = pos.y - lastPanPos.y;
            view.x -= dx / view.scale; view.y -= dy / view.scale;
            view.targetX = view.x; view.targetY = view.y;
        }
        lastPanPos = pos;
    }

    function onPointerUp(e) {
        if (!isMouseDown) return;
        isMouseDown = false;
        const timeHeld = performance.now() - clickStartTime;
        const distMoved = Math.hypot(worldMouse.x - clickStartPos.x, worldMouse.y - clickStartPos.y);

        if (expandedCube) {
            if (!expandedCube.isPointInside(worldMouse.x, worldMouse.y) && !expandedCube.isCloseButtonHit(worldMouse.x, worldMouse.y)) {
                expandedCube.isExpanded = false;
                expandedCube = null;
            }
        } else if (draggedCube) {
            draggedCube.dragging = false;
            // The 'drag_end' is handled by the event-based lifetime in the ticker logic
            if (distMoved < CLICK_THRESHOLD_DIST && timeHeld < CLICK_THRESHOLD_TIME) {
                handleCubeClick(draggedCube);
            }
        } else if (isPanning && distMoved < CLICK_THRESHOLD_DIST && timeHeld < CLICK_THRESHOLD_TIME) {
            gravityCenter = { ...worldMouse };
            feedToTicker({type: 'gravity_move', text: "מרכז הכבידה הוזז!", options:{color:'#8bc34a', lifetime: 3000}});
            updateGravityCenterMarker();
        }
        draggedCube = null; isPanning = false;
    }

    function onWheel(e) {
        e.preventDefault();
        if (expandedCube) return;
        if (view.isAnimating && viewportAnimation) { viewportAnimation.kill(); view.isAnimating = false; }
        const wheelDelta = e.deltaY;
        const zoomFactor = Math.exp(-wheelDelta * ZOOM_SENSITIVITY);
        const mouseWorldBefore = screenToWorld(screenMouse.x, screenMouse.y);
        view.scale = clamp(view.scale * zoomFactor, MIN_SCALE, MAX_SCALE);
        view.x = mouseWorldBefore.x - (screenMouse.x / view.scale);
        view.y = mouseWorldBefore.y - (screenMouse.y / view.scale);
        view.targetX = view.x; view.targetY = view.y; view.targetScale = view.scale;
        updateZoomInfo();
    }

    function updateGravityCenterMarker() {
        const marker = document.getElementById('gravityCenterMarker');
        if(gravityMode === 'center' || gravityMode === 'vortex') {
            const screenPos = worldToScreen(gravityCenter.x, gravityCenter.y);
            marker.style.left = `${screenPos.x}px`;
            marker.style.top = `${screenPos.y}px`;
            marker.style.opacity = '1';
            const scale = clamp(1 / view.scale, 0.5, 2);
            marker.style.transform = `translate(-50%, -50%) scale(${scale})`;
        } else {
            marker.style.opacity = '0';
        }
    }


    // =========================================
    // 7. Cube Content & Click Handling
    // =========================================
    function handleCubeClick(cube) {
        if (cube.isStar) {
            navigateToStar(cube.id);
        } else {
            if (expandedCube) expandedCube.isExpanded = false;
            expandedCube = cube;
            cube.isExpanded = true;
            centerViewOn(cube.x, cube.y, 1.2, false);
        }
    }

    function getCubeContent(cubeId) {
        const cube = cubeData.find(c => c.id === cubeId);
        if (!cube) return "";
        switch(cubeId) {
            case 'orian': return `אוריין אדלני, יליד 1990.\nCreative Visionary.\nמתכנת, מעצב, מודליסט, אנימטור.\nפרילנסר מאז 2004.`;
            case 'psycho': return `בעל חברת הפקות וידאו PsychoFlash מאז 2011.\nניסיון בניהול, ניתוב, בימוי, הפקה, עריכה, ייעוץ טכני.`;
            case 'ps': return `עיבוד תמונה\nריטוש\nעיצוב גרפי לדפוס ולאינטרנט`;
            case 'ae': return `אנימציה (Motion Graphics)\nקומפוזיטינג\nVFX (אפקטים ויזואליים)`;
            case 'vmix': return `תכנות ואוטומציה\nניתוב ובקרה\nהפעלה בשידור חי`;
            case 'email': return `EdelenviProductions@gmail.com`;
            case 'phone': return `054-255-9027`;
            case 'facebook': return `חפשו "Orian Edlenvi" בפייסבוק`;
            default: return `פרטים עבור: ${cube.text}\n(${cube.type})\n\n...בקרוב יוזן תוכן נוסף...`;
        }
    }

    // =========================================
    // 8. Physics & Simulation Helpers
    // =========================================
    function resetPhysics(hardReset = false) {
        if (expandedCube) { expandedCube.isExpanded = false; expandedCube = null; }
        assignGridPositions();
        buildSprings();
        if(hardReset) {
            keyCubes.forEach(cube => {
                cube.x = cube.gridX + (Math.random() - 0.5) * 10;
                cube.y = cube.gridY + (Math.random() - 0.5) * 10;
                cube.vx = 0; cube.vy = 0;
                cube.dragging = false;
            });
        }
    }

    // =========================================
    // 9. NEW TICKER LOGIC
    // =========================================
    function initNewTicker() {
        const canvas = document.getElementById('ticker-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('ticker-container');
        const label = container.querySelector('.ticker-label');
        const popup = document.getElementById('popup');
        const popupContent = document.getElementById('popup-content');
        const popupClose = document.getElementById('popup-close');

        // --- FIX START: Hoist variables to the top of the function scope ---
        const queue = [];
        const active = [];
        let isDrag = false, startX = 0, vel = 0, startT = 0, paused = false;
        let last = 0, running = false;
        const BASE_SPD = 60, MASK = 40, GAP = 0;
        let labelW = 0;
        // --- FIX END ---
        
        function resize() {
            if (!label || !container || !canvas) return;
            labelW = label.clientWidth;
            canvas.width = container.clientWidth - labelW;
            canvas.height = container.clientHeight;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'right';
            ctx.direction = 'rtl';
        }
        window.addEventListener('resize', resize);
        resize();

        const ease = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

        class Msg {
            constructor(text, options = {}) {
                this.id = Math.random();
                this.src = text;
                this.opt = { color: '#fff', bold: false, hold: false, spacer: false, details: null, lifetime: Infinity, type: 'generic', ...options };
                if (typeof this.opt.lifetime === 'number') {
                    this.expireTime = performance.now() + this.opt.lifetime;
                }
                this.txt = this._val(); this._measure();
                this.x = -18; this.ease = false; this.sx = 0; this.tx = 0; this.es = 0; this.ed = 400; this.first = true;
                this.sep = this.txt === '|' || this.opt.spacer;
            }
            _val() { return typeof this.src === 'function' ? this.src() : this.src; }
            _measure() { ctx.font = `${this.opt.bold ? 'bold ' : ''}16px sans-serif`; this.txt = this._val(); this.w = (this.opt.spacer ? 0 : ctx.measureText(this.txt).width) + 36; this.tw = this.w - 36; }
            get right() { return this.x + 18; }
            get left() { return this.right - this.w; }
            start(tgt, now, d = 400) { this.ease = true; this.sx = this.x; this.tx = tgt; this.es = now; this.ed = d; }
            step(now) { const t = Math.min((now - this.es) / this.ed, 1); this.x = this.sx + (this.tx - this.sx) * ease(t); if (t >= 1) this.ease = false; }
            extended() { return this.opt.details || this.txt; }
            isExpired(now) {
                 if (this.opt.lifetime === 'event' && this.opt.eventId === 'drag' && !draggedCube) return true;
                 if (this.expireTime && now > this.expireTime) return true;
                 return false;
            }
        }
        
        function start() { if(running) return; running = true; last = performance.now(); requestAnimationFrame(frame); } 

        feedToTicker = ({ type, text, options }) => {
            const now = performance.now();
            const cooldown = tickerMessageCooldowns.get(type) || 0;
            if (now < cooldown) return; // Cooldown active

            // Set cooldown for this message type
            tickerMessageCooldowns.set(type, now + (options.cooldown || 2000));
            
            // Prevent duplicate event-based messages
            if(options.lifetime === 'event' && active.some(m => m.opt.eventId === options.eventId)) return;

            queue.push({ text, options: { ...options, type } });
            if (!running) start();
        };

        // Populate initial messages
        feedToTicker({ type: 'welcome', text: 'ברוכים הבאים לסימולציה האינטראקטיבית', options: { color: '#4caf50', details: 'גרסה 4.1 - טיקר דינמי מגיב לאירועים בזמן אמת. נסו את הכפתורים!' } });
        feedToTicker({ type: 'instructions', text: 'גררו ריבועים, לחצו על כפתורים, ושחקו עם הפיזיקה', options: { color: '#03a9f4' } });
        
        const ptrX = e => e.clientX ?? e.touches[0].clientX;

        const shift = dx => active.forEach(m => m.x += dx);
        container.addEventListener('wheel', e => { shift(-(e.deltaY || e.deltaX)); e.preventDefault(); }, { passive: false });

        container.addEventListener('pointerdown', e => { isDrag = true; vel = 0; startX = ptrX(e); startT = e.timeStamp; container.setPointerCapture(e.pointerId); });
        const end = e => { if (!isDrag) return; isDrag = false; container.releasePointerCapture(e.pointerId); };
        container.addEventListener('pointerup', end); container.addEventListener('pointercancel', end);
        container.addEventListener('pointermove', e => { if (isDrag) { const x = ptrX(e), dx = x - startX; shift(dx); const dt = e.timeStamp - startT; if (dt > 0) vel = dx / dt; startX = x; startT = e.timeStamp; } });

        container.addEventListener('pointerenter', () => paused = true);
        container.addEventListener('pointerleave', () => paused = false);

        const open = t => { popupContent.textContent = t; popup.style.display = 'flex'; paused = true; };
        const close = () => { popup.style.display = 'none'; paused = false; };
        popupClose.addEventListener('click', close);
        popup.addEventListener('click', e => { if (e.target === popup) close(); });

        container.addEventListener('click', e => {
            if (Math.abs(vel) > 0.1) return;
            const rect = canvas.getBoundingClientRect();
            const lx = e.clientX - rect.left;
            if (lx < 0 || lx > canvas.width) return;
            for (let i = active.length - 1; i >= 0; i--) {
                const m = active[i];
                if (m.sep) continue;
                if (lx >= m.left && lx <= m.right) { open(m.extended()); return; }
            }
        });

        const holdable = m => !m.sep && (m.opt.hold || m.tw > 450);
        const recycle = m => {
            if (m.opt.lifetime !== 'single' && m.opt.lifetime !== 'event' && typeof m.opt.lifetime !== 'number') {
                feedToTicker({ type: m.opt.type, text: m.src, options: m.opt });
            }
        };

        const make = d => d instanceof Msg ? d : new Msg(d.text ?? d, d.options ?? {});

        function frame(ts) {
            const now = performance.now();
            const dt = (ts - last) / 1000; last = ts;
            if (!active.length && queue.length) active.push(make(queue.shift()));
            if (!isDrag && Math.abs(vel) > 0.0001) { shift(vel * dt * 1000); vel *= 0.92; } // friction

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let currentSpeed = BASE_SPD * (1 + Math.min(queue.length, 5) * 0.5); // Speed up based on queue length

            for (const m of active) {
                ctx.font = `${m.opt.bold ? 'bold ' : ''}16px sans-serif`;
                const nt = m._val(); if (nt !== m.txt) { m._measure(); }
                if (m.first) { m.x += currentSpeed * dt * 2; if (m.right >= -GAP) m.first = false; }
                else if (m.ease) { m.step(ts); } else if (!isDrag && !paused) { m.x += currentSpeed * dt; }
                ctx.fillStyle = m.opt.color; ctx.fillText(m.txt, m.x + 18, canvas.height / 2);
            }

            for (let i = 1; i < active.length; i++) { const p = active[i - 1], c = active[i]; const maxR = p.left - GAP; if (c.right > maxR) c.x = maxR - 18; }
            if (active.length === 1 && !queue.length) { const m = active[0]; if (holdable(m) && !m.ease && !isDrag && !paused) { const c = (canvas.width + m.w) / 2; if (Math.abs(m.right - c) > 1) m.start(c, ts, 600); } }

            // Check for expired and off-screen messages
            for (let i = active.length - 1; i >= 0; i--) {
                const m = active[i];
                if (m.isExpired(now) || m.left > canvas.width + MASK) {
                    const [removed] = active.splice(i, 1);
                    if(!removed.isExpired(now)) recycle(removed);
                }
            }
            if (active.length && active[active.length-1].right < -MASK) { recycle(active.pop()); }
            
            while (queue.length) {
                 if (active.length && !active[active.length - 1].sep) active.push(new Msg('|', { color: '#aaa', lifetime: 'single' }));
                 active.push(make(queue.shift()));
            }

            if (active.length || queue.length) requestAnimationFrame(frame); else {
                running = false;
                // If queue becomes empty, add a default message to keep it alive
                setTimeout(() => {
                    if (!active.length && !queue.length) {
                        feedToTicker({ type: 'idle', text: 'המערכת ממתינה לפעולה...', options: { color: '#999' } });
                    }
                }, 5000);
            }
        }
    }

    // =========================================
    // 10. Idle Mode & Demo
    // =========================================
    function resetIdleTimer() {
        clearTimeout(idleTimeout);
        clearInterval(demoInterval);
        idleTimeout = setTimeout(startIdleMode, IDLE_TIME_MS);
    }

    function startIdleMode() {
        feedToTicker({type: 'demo_mode', text: "מצב הדגמה הופעל. המערכת משתלטת...", options:{color:'#87CEEB', bold:true, hold:true, lifetime: 'single'}});
        runDemoAction();
        demoInterval = setInterval(runDemoAction, Math.random() * 5000 + 5000);
    }

    function runDemoAction() {
        const starCubes = keyCubes.filter(c => c.isStar);
        const actions = [
            () => { const randomStar = starCubes[Math.floor(Math.random() * starCubes.length)]; if(randomStar) navigateToStar(randomStar.id); },
            () => document.getElementById('earthquakeBtn').click(),
            () => { document.getElementById('earthquakeBtn').click(); setTimeout(() => document.getElementById('earthquakeBtn').click(), 500) },
            () => document.getElementById('windBtn').click(),
            () => { const sel = document.getElementById('layout-select'); sel.selectedIndex = Math.floor(Math.random() * sel.options.length); sel.dispatchEvent(new Event('change')); },
            () => document.getElementById('toggleOrbitBtn').click(),
            () => document.getElementById('toggleWanderBtn').click(),
        ];
        if (expandedCube) {
            expandedCube.isExpanded = false; expandedCube = null;
        } else {
             const randomAction = actions[Math.floor(Math.random() * actions.length)];
             randomAction();
        }
    }
    
    // =========================================
    // 11. Live Data Ticker Updates
    // =========================================
    function updateTickerWithLiveData() {
        // Energy Level
        if (totalKineticEnergy > 600000) {
            feedToTicker({
                type: 'high_energy',
                text: `רמת אנרגיה גבוהה: ${Math.round(totalKineticEnergy / 1000)}k`,
                options: { color: '#f44336', bold: true, cooldown: 5000 }
            });
        } else if (totalKineticEnergy < 1000 && !isMouseDown) {
            feedToTicker({
                type: 'low_energy',
                text: 'המערכת רגועה...',
                options: { color: '#4caf50', cooldown: 10000 }
            });
        }
        
        // Gravity Mode specific
        if (gravityMode === 'vortex') {
             feedToTicker({
                type: 'vortex_active',
                text: () => `עוצמת מערבולת: ${vortexStrength}`,
                options: { color: '#9c27b0', cooldown: 3000 }
            });
        }
    }


    // =========================================
    // 12. Main Animation Loop & HUD
    // =========================================
    function updateHUD() {
        const objectCountEl = document.getElementById('objectCount');
        const physicsStatusEl = document.getElementById('physicsStatus');
        const mouseCoordsEl = document.getElementById('mouseCoords');
        const fpsDisplayEl = document.getElementById('fpsDisplay');
        const energyDisplayEl = document.getElementById('energyDisplay');

        if(objectCountEl) objectCountEl.textContent = `אובייקטים: ${keyCubes.length}`;
        if(physicsStatusEl) {
            let gravText = document.querySelector(`#gravity-select option[value="${gravityMode}"]`).textContent;
            let status = `כבידה: ${gravText}`;
            if(orbitEnabled) status += " | סיבוב";
            if(wanderEnabled) status += " | שיטוט";
            physicsStatusEl.textContent = status;
        }
        if(mouseCoordsEl) mouseCoordsEl.textContent = `עכבר: (${Math.round(worldMouse.x)}, ${Math.round(worldMouse.y)})`;
        if(fpsDisplayEl) fpsDisplayEl.textContent = `FPS: ${fps}`;
        if(energyDisplayEl) energyDisplayEl.textContent = `אנרגיה: ${Math.round(totalKineticEnergy / 1000)}k`;
    }

    function animate(timestamp) {
        requestAnimationFrame(animate);
        if(!lastTimestamp) lastTimestamp = timestamp;
        const dt = Math.min(0.033, (timestamp - lastTimestamp) / 1000);

        frameCount++;
        if (timestamp - lastFpsUpdate > 1000) {
            fps = frameCount;
            frameCount = 0;
            lastFpsUpdate = timestamp;
            updateTickerWithLiveData(); // Update ticker once per second
        }
        
        lastTimestamp = timestamp;

        springs.forEach(spring => spring.update());
        
        totalKineticEnergy = 0;
        keyCubes.forEach(cube => { 
            cube.handleInteractions(keyCubes);
            cube.update(dt); 
            const vSq = cube.vx * cube.vx + cube.vy * cube.vy;
            totalKineticEnergy += 0.5 * cube.mass * vSq;
        });

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(view.scale, view.scale);
        ctx.translate(-view.x, -view.y);

        springs.forEach(spring => spring.draw(ctx));
        keyCubes.sort((a,b) => a.expandProgress - b.expandProgress).forEach(cube => { cube.draw(ctx); });

        ctx.restore();
        updateGravityCenterMarker();
        updateHUD();
    }

    window.onload = init;
    </script>
</body>
</html>
